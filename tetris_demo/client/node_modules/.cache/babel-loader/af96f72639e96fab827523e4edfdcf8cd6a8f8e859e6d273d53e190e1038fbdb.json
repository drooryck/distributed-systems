{"ast":null,"code":"import{io}from'socket.io-client';import{EventEmitter}from'events';import{saveGameSession,getGameSession,clearGameSession}from'./sessionStorage';class ServerConnectionManager extends EventEmitter{constructor(){super();this.connections={};this.serverList=[];this.activeSocket=null;this.leaderServer=null;this.socketId=null;this.hasRejoinedRoom=false;// Configuration\nthis.debug=true;this.autoReconnect=true;this.reconnectInterval=2000;// Status tracking\nthis.initialized=false;this.reconnectTimer=null;}log(message){if(this.debug){console.log(`[ServerManager] ${message}`);}}async initialize(){let onConnectedCallback=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let onStateChangeCallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let serverList=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(this.initialized){return;}this.onConnectedCallback=onConnectedCallback;this.onStateChangeCallback=onStateChangeCallback;try{// Use provided server list or default to localhost ports\nthis.serverList=serverList||[{id:0,host:'localhost',port:3001},{id:1,host:'localhost',port:3002},{id:2,host:'localhost',port:3003}];this.log(`Initializing connection manager with ${this.serverList.length} servers`);// Connect to all available servers\nconst connectionPromises=this.serverList.map(server=>{const serverUrl=`http://${server.host}:${server.port}`;return this.connectToServer(server,serverUrl);});// Wait for all connection attempts (some may fail, that's expected)\nawait Promise.allSettled(connectionPromises);this.initialized=true;// If we don't have a leader yet, try a specific check\nif(!this.leaderServer){await this.findLeader();}// If still no leader, try the first available server\nif(!this.leaderServer){this.findFirstAvailableServer();}}catch(error){this.log(`Initialization error: ${error.message}`);throw new Error(`Failed to initialize server connection: ${error.message}`);}}async connectToServer(server,serverUrl){this.log(`Connecting to server ${server.id} at ${serverUrl}`);// Create connection entry\nconst connection={id:server.id,url:serverUrl,config:server,socket:null,isConnected:false,isLeader:false,lastActivity:Date.now()};// Connect to the server\nconst socket=io(serverUrl,{reconnection:false,// We'll handle reconnection manually\ntimeout:5000});connection.socket=socket;this.connections[server.id]=connection;return new Promise((resolve,reject)=>{// Set up connection timeout\nconst timeout=setTimeout(()=>{socket.close();reject(new Error(`Connection timeout to ${serverUrl}`));},5000);// Handle connection\nsocket.on('connect',()=>{clearTimeout(timeout);this.log(`Connected to server ${server.id} at ${serverUrl}`);connection.isConnected=true;connection.lastActivity=Date.now();// Check if this server is the leader\nsocket.emit('checkLeader',{},response=>{connection.isLeader=response.isLeader;// If this is the leader, use it as the active server\nif(response.isLeader&&!this.leaderServer){this.setActiveLeader(connection);}resolve(connection);});});// Handle connection error\nsocket.on('connect_error',error=>{clearTimeout(timeout);this.log(`Connection error to ${serverUrl}: ${error.message}`);reject(error);});// Handle disconnection\nsocket.on('disconnect',()=>{this.log(`Disconnected from ${serverUrl}`);connection.isConnected=false;// If this was the leader, find a new one\nif(this.leaderServer===connection){this.log(`Leader disconnected, finding new leader...`);this.leaderServer=null;this.activeSocket=null;// Notify about server change\nif(this.onStateChangeCallback){this.onStateChangeCallback({type:'leaderDisconnected'});}// Try to find a new leader\nthis.findLeader();}});}).catch(error=>{this.log(`Failed to connect to ${serverUrl}: ${error.message}`);// Don't throw - we just continue with other servers\n});}async findLeader(){this.log('Searching for leader server...');const checkLeaderPromises=[];// Ask all connected servers if they're the leader\nfor(const id in this.connections){const connection=this.connections[id];if(connection.isConnected&&connection.socket){const checkPromise=new Promise(resolve=>{connection.socket.emit('checkLeader',{},response=>{if(response){connection.isLeader=response.isLeader;if(response.isLeader){this.log(`Server ${connection.url} confirmed as leader`);this.setActiveLeader(connection);}}resolve();});});checkLeaderPromises.push(checkPromise);}}// Wait for all checks to complete\nawait Promise.all(checkLeaderPromises);return this.leaderServer!==null;}findFirstAvailableServer(){// If no leader found, try the first connected server\nif(!this.leaderServer){for(const id in this.connections){const connection=this.connections[id];if(connection.isConnected){this.log(`No leader found. Using ${connection.url} as temporary server`);this.setActiveLeader(connection);break;}}}// If still no server available, schedule reconnection attempts\nif(!this.leaderServer&&this.autoReconnect){if(this.reconnectTimer){clearTimeout(this.reconnectTimer);}this.reconnectTimer=setTimeout(()=>{this.log('No servers available, attempting to reconnect...');// Try to connect to all servers again\nfor(const server of this.serverList){const serverUrl=`http://${server.host}:${server.port}`;this.connectToServer(server,serverUrl).catch(()=>{});// Ignore errors, we'll handle them in the connection promise\n}// Check again if we found a leader\nsetTimeout(()=>{if(!this.leaderServer){this.findLeader();}// If still no leader, continue trying the first available\nif(!this.leaderServer){this.findFirstAvailableServer();}},1000);},this.reconnectInterval);}}setActiveLeader(connection){this.leaderServer=connection;this.activeSocket=connection.socket;this.log(`Active leader set to ${connection.url}`);// Forward events from this socket\nthis.forwardEvents(connection.socket);// Request initial state\nconnection.socket.emit('requestInitialState');// Try to rejoin a room if we have saved session\nthis.attemptRoomRejoin(connection.socket);// Call the connected callback if provided\nif(this.onConnectedCallback){this.onConnectedCallback(this.activeSocket);}// Notify about server change\nif(this.onStateChangeCallback){this.onStateChangeCallback({type:'leaderChanged',server:connection});}}forwardEvents(socket){if(!socket)return;// Store socket ID when available\nsocket.on('connect',()=>{this.socketId=socket.id;});// Forward common events from the socket to this event emitter\nconst eventsToForward=['init','gameState','roomCreated','roomJoined','roomRejoined','roomLeft','playerJoined','playerLeft','playerReady','gameStarted','gameOver','error','disconnect'];eventsToForward.forEach(eventName=>{socket.on(eventName,data=>{// Add debug logging to see what data is received\nconsole.log(`[DEBUG] Received ${eventName} event with data:`,typeof data,data);// Make sure we're receiving an object for the init event\nif(eventName==='init'&&typeof data==='string'){console.warn(`[DEBUG] Received init event with string instead of object: \"${data}\"`);// Try to convert if it's a stringified JSON\ntry{const parsedData=JSON.parse(data);this.log(`Converted string to object for init event`);data=parsedData;}catch(e){this.log(`Could not parse init string as JSON, creating default homescreen state`);data={appPhase:'homescreen',socketId:socket.id,players:{},activePlayers:[],readyPlayers:[],gameInProgress:false};}}this.emit(eventName,data);});});}attemptRoomRejoin(socket){const session=getGameSession();if(session&&session.roomCode){this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);socket.emit('rejoinRoom',{roomCode:session.roomCode,playerName:session.playerName,previousSocketId:session.socketId});}}emit(eventName,data){// For non-EventEmitter events, send to server\nif(eventName!=='newListener'&&eventName!=='removeListener'){if(this.activeSocket){this.activeSocket.emit(eventName,data);}else{this.log(`Cannot emit ${eventName}: no active socket`);}}// Always forward all events to local listeners - use the actual data parameter\nreturn super.emit(eventName,data);}on(eventName,listener){return super.on(eventName,listener);}getSocket(){return this.activeSocket;}getSocketId(){return this.socketId;}disconnect(){for(const id in this.connections){const connection=this.connections[id];if(connection.socket){connection.socket.disconnect();}}this.connections={};this.leaderServer=null;this.activeSocket=null;this.initialized=false;if(this.reconnectTimer){clearTimeout(this.reconnectTimer);this.reconnectTimer=null;}}}// Create a singleton instance\nconst serverManager=new ServerConnectionManager();export default serverManager;","map":{"version":3,"names":["io","EventEmitter","saveGameSession","getGameSession","clearGameSession","ServerConnectionManager","constructor","connections","serverList","activeSocket","leaderServer","socketId","hasRejoinedRoom","debug","autoReconnect","reconnectInterval","initialized","reconnectTimer","log","message","console","initialize","onConnectedCallback","arguments","length","undefined","onStateChangeCallback","id","host","port","connectionPromises","map","server","serverUrl","connectToServer","Promise","allSettled","findLeader","findFirstAvailableServer","error","Error","connection","url","config","socket","isConnected","isLeader","lastActivity","Date","now","reconnection","timeout","resolve","reject","setTimeout","close","on","clearTimeout","emit","response","setActiveLeader","type","catch","checkLeaderPromises","checkPromise","push","all","forwardEvents","attemptRoomRejoin","eventsToForward","forEach","eventName","data","warn","parsedData","JSON","parse","e","appPhase","players","activePlayers","readyPlayers","gameInProgress","session","roomCode","playerName","previousSocketId","listener","getSocket","getSocketId","disconnect","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.connections = {};\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n    this.hasRejoinedRoom = false;\n    \n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n    \n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  \n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  \n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    \n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    \n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = serverList || [\n        { id: 0, host: 'localhost', port: 3001 },\n        { id: 1, host: 'localhost', port: 3002 },\n        { id: 2, host: 'localhost', port: 3003 }\n      ];\n      \n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n      \n      // Connect to all available servers\n      const connectionPromises = this.serverList.map(server => {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        return this.connectToServer(server, serverUrl);\n      });\n      \n      // Wait for all connection attempts (some may fail, that's expected)\n      await Promise.allSettled(connectionPromises);\n      \n      this.initialized = true;\n      \n      // If we don't have a leader yet, try a specific check\n      if (!this.leaderServer) {\n        await this.findLeader();\n      }\n      \n      // If still no leader, try the first available server\n      if (!this.leaderServer) {\n        this.findFirstAvailableServer();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      throw new Error(`Failed to initialize server connection: ${error.message}`);\n    }\n  }\n  \n  async connectToServer(server, serverUrl) {\n    this.log(`Connecting to server ${server.id} at ${serverUrl}`);\n    \n    // Create connection entry\n    const connection = {\n      id: server.id,\n      url: serverUrl,\n      config: server,\n      socket: null,\n      isConnected: false,\n      isLeader: false,\n      lastActivity: Date.now()\n    };\n    \n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false, // We'll handle reconnection manually\n      timeout: 5000\n    });\n    \n    connection.socket = socket;\n    this.connections[server.id] = connection;\n    \n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n      \n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server ${server.id} at ${serverUrl}`);\n        connection.isConnected = true;\n        connection.lastActivity = Date.now();\n        \n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, (response) => {\n          connection.isLeader = response.isLeader;\n          \n          // If this is the leader, use it as the active server\n          if (response.isLeader && !this.leaderServer) {\n            this.setActiveLeader(connection);\n          }\n          \n          resolve(connection);\n        });\n      });\n      \n      // Handle connection error\n      socket.on('connect_error', (error) => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n      \n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.log(`Disconnected from ${serverUrl}`);\n        connection.isConnected = false;\n        \n        // If this was the leader, find a new one\n        if (this.leaderServer === connection) {\n          this.log(`Leader disconnected, finding new leader...`);\n          this.leaderServer = null;\n          this.activeSocket = null;\n          \n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'leaderDisconnected'\n            });\n          }\n          \n          // Try to find a new leader\n          this.findLeader();\n        }\n      });\n    }).catch(error => {\n      this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n      // Don't throw - we just continue with other servers\n    });\n  }\n  \n  async findLeader() {\n    this.log('Searching for leader server...');\n    \n    const checkLeaderPromises = [];\n    \n    // Ask all connected servers if they're the leader\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.isConnected && connection.socket) {\n        const checkPromise = new Promise(resolve => {\n          connection.socket.emit('checkLeader', {}, (response) => {\n            if (response) {\n              connection.isLeader = response.isLeader;\n              if (response.isLeader) {\n                this.log(`Server ${connection.url} confirmed as leader`);\n                this.setActiveLeader(connection);\n              }\n            }\n            resolve();\n          });\n        });\n        \n        checkLeaderPromises.push(checkPromise);\n      }\n    }\n    \n    // Wait for all checks to complete\n    await Promise.all(checkLeaderPromises);\n    \n    return this.leaderServer !== null;\n  }\n  \n  findFirstAvailableServer() {\n    // If no leader found, try the first connected server\n    if (!this.leaderServer) {\n      for (const id in this.connections) {\n        const connection = this.connections[id];\n        if (connection.isConnected) {\n          this.log(`No leader found. Using ${connection.url} as temporary server`);\n          this.setActiveLeader(connection);\n          break;\n        }\n      }\n    }\n    \n    // If still no server available, schedule reconnection attempts\n    if (!this.leaderServer && this.autoReconnect) {\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n      \n      this.reconnectTimer = setTimeout(() => {\n        this.log('No servers available, attempting to reconnect...');\n        \n        // Try to connect to all servers again\n        for (const server of this.serverList) {\n          const serverUrl = `http://${server.host}:${server.port}`;\n          this.connectToServer(server, serverUrl)\n            .catch(() => {}); // Ignore errors, we'll handle them in the connection promise\n        }\n        \n        // Check again if we found a leader\n        setTimeout(() => {\n          if (!this.leaderServer) {\n            this.findLeader();\n          }\n          \n          // If still no leader, continue trying the first available\n          if (!this.leaderServer) {\n            this.findFirstAvailableServer();\n          }\n        }, 1000);\n      }, this.reconnectInterval);\n    }\n  }\n  \n  setActiveLeader(connection) {\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    this.log(`Active leader set to ${connection.url}`);\n    \n    // Forward events from this socket\n    this.forwardEvents(connection.socket);\n    \n    // Request initial state\n    connection.socket.emit('requestInitialState');\n    \n    // Try to rejoin a room if we have saved session\n    this.attemptRoomRejoin(connection.socket);\n    \n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(this.activeSocket);\n    }\n    \n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'leaderChanged',\n        server: connection\n      });\n    }\n  }\n  \n  forwardEvents(socket) {\n    if (!socket) return;\n    \n    // Store socket ID when available\n    socket.on('connect', () => {\n      this.socketId = socket.id;\n    });\n    \n    // Forward common events from the socket to this event emitter\n    const eventsToForward = [\n      'init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined',\n      'roomLeft', 'playerJoined', 'playerLeft', 'playerReady',\n      'gameStarted', 'gameOver', 'error', 'disconnect'\n    ];\n    \n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, (data) => {\n        // Add debug logging to see what data is received\n        console.log(`[DEBUG] Received ${eventName} event with data:`, typeof data, data);\n        \n        // Make sure we're receiving an object for the init event\n        if (eventName === 'init' && typeof data === 'string') {\n          console.warn(`[DEBUG] Received init event with string instead of object: \"${data}\"`);\n          // Try to convert if it's a stringified JSON\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = { \n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        \n        this.emit(eventName, data);\n      });\n    });\n  }\n  \n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n      \n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId\n      });\n    }\n  }\n  \n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n    \n    // Always forward all events to local listeners - use the actual data parameter\n    return super.emit(eventName, data);\n  }\n  \n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  \n  getSocket() {\n    return this.activeSocket;\n  }\n  \n  getSocketId() {\n    return this.socketId;\n  }\n  \n  disconnect() {\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.socket) {\n        connection.socket.disconnect();\n      }\n    }\n    \n    this.connections = {};\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.initialized = false;\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}