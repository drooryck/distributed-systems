{"ast":null,"code":"import{io}from'socket.io-client';/**\n * Connect to the cluster of servers with automatic leader discovery\n * Attempts to connect to each server in sequence until it finds the leader\n */export async function connectToCluster(){try{// Load cluster configuration\nconst response=await fetch('/config.json');const config=await response.json();// Use default server address if available\nconst defaultServer=config.serverAddress||'http://localhost:3001';// Try connecting to the default server first\ntry{console.log(`Trying to connect to default server: ${defaultServer}`);const socket=io(defaultServer,{timeout:5000});// Wait to see if this connection succeeds\nconst result=await new Promise((resolve,reject)=>{let timeoutId=setTimeout(()=>{socket.disconnect();reject(new Error(`Connection to ${defaultServer} timed out`));},5000);socket.on('connect',()=>{socket.emit('getLeaderInfo');});socket.on('leaderInfo',info=>{clearTimeout(timeoutId);if(info.isLeader){console.log(`Connected to leader at ${defaultServer}`);resolve({socket,redirect:false});}else if(info.leaderAddress){console.log(`Redirecting to leader at ${info.leaderAddress}`);socket.disconnect();resolve({socket:null,redirect:true,redirectTo:info.leaderAddress});}else{socket.disconnect();reject(new Error('No leader information available'));}});socket.on('connect_error',err=>{clearTimeout(timeoutId);socket.disconnect();reject(err);});});// If we need to redirect to the leader\nif(result.redirect){return io(result.redirectTo);}return result.socket;}catch(defaultServerError){console.warn('Failed to connect to default server:',defaultServerError);// If we have multiple servers configured, try them in sequence\nif(config.clusterServers&&Array.isArray(config.clusterServers)&&config.clusterServers.length>0){for(const serverUrl of config.clusterServers){try{console.log(`Trying to connect to ${serverUrl}`);const socket=io(serverUrl,{timeout:3000});// Wait to see if this connection succeeds\nconst result=await new Promise((resolve,reject)=>{let timeoutId=setTimeout(()=>{socket.disconnect();reject(new Error(`Connection to ${serverUrl} timed out`));},3000);socket.on('connect',()=>{socket.emit('getLeaderInfo');});socket.on('leaderInfo',info=>{clearTimeout(timeoutId);if(info.isLeader){console.log(`Connected to leader at ${serverUrl}`);resolve({socket,redirect:false});}else if(info.leaderAddress){console.log(`Redirecting to leader at ${info.leaderAddress}`);socket.disconnect();resolve({socket:null,redirect:true,redirectTo:info.leaderAddress});}else{socket.disconnect();reject(new Error('No leader information available'));}});socket.on('connect_error',err=>{clearTimeout(timeoutId);socket.disconnect();reject(err);});});// If we need to redirect to the leader\nif(result.redirect){return io(result.redirectTo);}return result.socket;}catch(error){console.warn(`Failed to connect to ${serverUrl}:`,error);// Continue trying next server\n}}}// If all attempts fail, throw an error\nthrow new Error('Could not connect to any server in the cluster');}}catch(error){console.error('Server discovery failed:',error);throw error;}}","map":{"version":3,"names":["io","connectToCluster","response","fetch","config","json","defaultServer","serverAddress","console","log","socket","timeout","result","Promise","resolve","reject","timeoutId","setTimeout","disconnect","Error","on","emit","info","clearTimeout","isLeader","redirect","leaderAddress","redirectTo","err","defaultServerError","warn","clusterServers","Array","isArray","length","serverUrl","error"],"sources":["/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/serverDiscovery.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\n/**\n * Connect to the cluster of servers with automatic leader discovery\n * Attempts to connect to each server in sequence until it finds the leader\n */\nexport async function connectToCluster() {\n  try {\n    // Load cluster configuration\n    const response = await fetch('/config.json');\n    const config = await response.json();\n    \n    // Use default server address if available\n    const defaultServer = config.serverAddress || 'http://localhost:3001';\n    \n    // Try connecting to the default server first\n    try {\n      console.log(`Trying to connect to default server: ${defaultServer}`);\n      const socket = io(defaultServer, { timeout: 5000 });\n      \n      // Wait to see if this connection succeeds\n      const result = await new Promise((resolve, reject) => {\n        let timeoutId = setTimeout(() => {\n          socket.disconnect();\n          reject(new Error(`Connection to ${defaultServer} timed out`));\n        }, 5000);\n        \n        socket.on('connect', () => {\n          socket.emit('getLeaderInfo');\n        });\n        \n        socket.on('leaderInfo', (info) => {\n          clearTimeout(timeoutId);\n          if (info.isLeader) {\n            console.log(`Connected to leader at ${defaultServer}`);\n            resolve({ socket, redirect: false });\n          } else if (info.leaderAddress) {\n            console.log(`Redirecting to leader at ${info.leaderAddress}`);\n            socket.disconnect();\n            resolve({ socket: null, redirect: true, redirectTo: info.leaderAddress });\n          } else {\n            socket.disconnect();\n            reject(new Error('No leader information available'));\n          }\n        });\n        \n        socket.on('connect_error', (err) => {\n          clearTimeout(timeoutId);\n          socket.disconnect();\n          reject(err);\n        });\n      });\n      \n      // If we need to redirect to the leader\n      if (result.redirect) {\n        return io(result.redirectTo);\n      }\n      \n      return result.socket;\n    } catch (defaultServerError) {\n      console.warn('Failed to connect to default server:', defaultServerError);\n      \n      // If we have multiple servers configured, try them in sequence\n      if (config.clusterServers && Array.isArray(config.clusterServers) && config.clusterServers.length > 0) {\n        for (const serverUrl of config.clusterServers) {\n          try {\n            console.log(`Trying to connect to ${serverUrl}`);\n            const socket = io(serverUrl, { timeout: 3000 });\n            \n            // Wait to see if this connection succeeds\n            const result = await new Promise((resolve, reject) => {\n              let timeoutId = setTimeout(() => {\n                socket.disconnect();\n                reject(new Error(`Connection to ${serverUrl} timed out`));\n              }, 3000);\n              \n              socket.on('connect', () => {\n                socket.emit('getLeaderInfo');\n              });\n              \n              socket.on('leaderInfo', (info) => {\n                clearTimeout(timeoutId);\n                if (info.isLeader) {\n                  console.log(`Connected to leader at ${serverUrl}`);\n                  resolve({ socket, redirect: false });\n                } else if (info.leaderAddress) {\n                  console.log(`Redirecting to leader at ${info.leaderAddress}`);\n                  socket.disconnect();\n                  resolve({ socket: null, redirect: true, redirectTo: info.leaderAddress });\n                } else {\n                  socket.disconnect();\n                  reject(new Error('No leader information available'));\n                }\n              });\n              \n              socket.on('connect_error', (err) => {\n                clearTimeout(timeoutId);\n                socket.disconnect();\n                reject(err);\n              });\n            });\n            \n            // If we need to redirect to the leader\n            if (result.redirect) {\n              return io(result.redirectTo);\n            }\n            \n            return result.socket;\n          } catch (error) {\n            console.warn(`Failed to connect to ${serverUrl}:`, error);\n            // Continue trying next server\n          }\n        }\n      }\n      \n      // If all attempts fail, throw an error\n      throw new Error('Could not connect to any server in the cluster');\n    }\n  } catch (error) {\n    console.error('Server discovery failed:', error);\n    throw error;\n  }\n}"],"mappings":"AAAA,OAASA,EAAE,KAAQ,kBAAkB,CAErC;AACA;AACA;AACA,GACA,MAAO,eAAe,CAAAC,gBAAgBA,CAAA,CAAG,CACvC,GAAI,CACF;AACA,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,cAAc,CAAC,CAC5C,KAAM,CAAAC,MAAM,CAAG,KAAM,CAAAF,QAAQ,CAACG,IAAI,CAAC,CAAC,CAEpC;AACA,KAAM,CAAAC,aAAa,CAAGF,MAAM,CAACG,aAAa,EAAI,uBAAuB,CAErE;AACA,GAAI,CACFC,OAAO,CAACC,GAAG,CAAC,wCAAwCH,aAAa,EAAE,CAAC,CACpE,KAAM,CAAAI,MAAM,CAAGV,EAAE,CAACM,aAAa,CAAE,CAAEK,OAAO,CAAE,IAAK,CAAC,CAAC,CAEnD;AACA,KAAM,CAAAC,MAAM,CAAG,KAAM,IAAI,CAAAC,OAAO,CAAC,CAACC,OAAO,CAAEC,MAAM,GAAK,CACpD,GAAI,CAAAC,SAAS,CAAGC,UAAU,CAAC,IAAM,CAC/BP,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBH,MAAM,CAAC,GAAI,CAAAI,KAAK,CAAC,iBAAiBb,aAAa,YAAY,CAAC,CAAC,CAC/D,CAAC,CAAE,IAAI,CAAC,CAERI,MAAM,CAACU,EAAE,CAAC,SAAS,CAAE,IAAM,CACzBV,MAAM,CAACW,IAAI,CAAC,eAAe,CAAC,CAC9B,CAAC,CAAC,CAEFX,MAAM,CAACU,EAAE,CAAC,YAAY,CAAGE,IAAI,EAAK,CAChCC,YAAY,CAACP,SAAS,CAAC,CACvB,GAAIM,IAAI,CAACE,QAAQ,CAAE,CACjBhB,OAAO,CAACC,GAAG,CAAC,0BAA0BH,aAAa,EAAE,CAAC,CACtDQ,OAAO,CAAC,CAAEJ,MAAM,CAAEe,QAAQ,CAAE,KAAM,CAAC,CAAC,CACtC,CAAC,IAAM,IAAIH,IAAI,CAACI,aAAa,CAAE,CAC7BlB,OAAO,CAACC,GAAG,CAAC,4BAA4Ba,IAAI,CAACI,aAAa,EAAE,CAAC,CAC7DhB,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBJ,OAAO,CAAC,CAAEJ,MAAM,CAAE,IAAI,CAAEe,QAAQ,CAAE,IAAI,CAAEE,UAAU,CAAEL,IAAI,CAACI,aAAc,CAAC,CAAC,CAC3E,CAAC,IAAM,CACLhB,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBH,MAAM,CAAC,GAAI,CAAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC,CACtD,CACF,CAAC,CAAC,CAEFT,MAAM,CAACU,EAAE,CAAC,eAAe,CAAGQ,GAAG,EAAK,CAClCL,YAAY,CAACP,SAAS,CAAC,CACvBN,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBH,MAAM,CAACa,GAAG,CAAC,CACb,CAAC,CAAC,CACJ,CAAC,CAAC,CAEF;AACA,GAAIhB,MAAM,CAACa,QAAQ,CAAE,CACnB,MAAO,CAAAzB,EAAE,CAACY,MAAM,CAACe,UAAU,CAAC,CAC9B,CAEA,MAAO,CAAAf,MAAM,CAACF,MAAM,CACtB,CAAE,MAAOmB,kBAAkB,CAAE,CAC3BrB,OAAO,CAACsB,IAAI,CAAC,sCAAsC,CAAED,kBAAkB,CAAC,CAExE;AACA,GAAIzB,MAAM,CAAC2B,cAAc,EAAIC,KAAK,CAACC,OAAO,CAAC7B,MAAM,CAAC2B,cAAc,CAAC,EAAI3B,MAAM,CAAC2B,cAAc,CAACG,MAAM,CAAG,CAAC,CAAE,CACrG,IAAK,KAAM,CAAAC,SAAS,GAAI,CAAA/B,MAAM,CAAC2B,cAAc,CAAE,CAC7C,GAAI,CACFvB,OAAO,CAACC,GAAG,CAAC,wBAAwB0B,SAAS,EAAE,CAAC,CAChD,KAAM,CAAAzB,MAAM,CAAGV,EAAE,CAACmC,SAAS,CAAE,CAAExB,OAAO,CAAE,IAAK,CAAC,CAAC,CAE/C;AACA,KAAM,CAAAC,MAAM,CAAG,KAAM,IAAI,CAAAC,OAAO,CAAC,CAACC,OAAO,CAAEC,MAAM,GAAK,CACpD,GAAI,CAAAC,SAAS,CAAGC,UAAU,CAAC,IAAM,CAC/BP,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBH,MAAM,CAAC,GAAI,CAAAI,KAAK,CAAC,iBAAiBgB,SAAS,YAAY,CAAC,CAAC,CAC3D,CAAC,CAAE,IAAI,CAAC,CAERzB,MAAM,CAACU,EAAE,CAAC,SAAS,CAAE,IAAM,CACzBV,MAAM,CAACW,IAAI,CAAC,eAAe,CAAC,CAC9B,CAAC,CAAC,CAEFX,MAAM,CAACU,EAAE,CAAC,YAAY,CAAGE,IAAI,EAAK,CAChCC,YAAY,CAACP,SAAS,CAAC,CACvB,GAAIM,IAAI,CAACE,QAAQ,CAAE,CACjBhB,OAAO,CAACC,GAAG,CAAC,0BAA0B0B,SAAS,EAAE,CAAC,CAClDrB,OAAO,CAAC,CAAEJ,MAAM,CAAEe,QAAQ,CAAE,KAAM,CAAC,CAAC,CACtC,CAAC,IAAM,IAAIH,IAAI,CAACI,aAAa,CAAE,CAC7BlB,OAAO,CAACC,GAAG,CAAC,4BAA4Ba,IAAI,CAACI,aAAa,EAAE,CAAC,CAC7DhB,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBJ,OAAO,CAAC,CAAEJ,MAAM,CAAE,IAAI,CAAEe,QAAQ,CAAE,IAAI,CAAEE,UAAU,CAAEL,IAAI,CAACI,aAAc,CAAC,CAAC,CAC3E,CAAC,IAAM,CACLhB,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBH,MAAM,CAAC,GAAI,CAAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC,CACtD,CACF,CAAC,CAAC,CAEFT,MAAM,CAACU,EAAE,CAAC,eAAe,CAAGQ,GAAG,EAAK,CAClCL,YAAY,CAACP,SAAS,CAAC,CACvBN,MAAM,CAACQ,UAAU,CAAC,CAAC,CACnBH,MAAM,CAACa,GAAG,CAAC,CACb,CAAC,CAAC,CACJ,CAAC,CAAC,CAEF;AACA,GAAIhB,MAAM,CAACa,QAAQ,CAAE,CACnB,MAAO,CAAAzB,EAAE,CAACY,MAAM,CAACe,UAAU,CAAC,CAC9B,CAEA,MAAO,CAAAf,MAAM,CAACF,MAAM,CACtB,CAAE,MAAO0B,KAAK,CAAE,CACd5B,OAAO,CAACsB,IAAI,CAAC,wBAAwBK,SAAS,GAAG,CAAEC,KAAK,CAAC,CACzD;AACF,CACF,CACF,CAEA;AACA,KAAM,IAAI,CAAAjB,KAAK,CAAC,gDAAgD,CAAC,CACnE,CACF,CAAE,MAAOiB,KAAK,CAAE,CACd5B,OAAO,CAAC4B,KAAK,CAAC,0BAA0B,CAAEA,KAAK,CAAC,CAChD,KAAM,CAAAA,KAAK,CACb,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}