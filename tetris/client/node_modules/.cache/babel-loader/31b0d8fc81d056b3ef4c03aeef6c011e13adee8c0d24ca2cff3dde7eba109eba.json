{"ast":null,"code":"import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n\n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n\n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = serverList || [{\n        id: 0,\n        host: 'localhost',\n        port: 3001\n      }, {\n        id: 1,\n        host: 'localhost',\n        port: 3002\n      }, {\n        id: 2,\n        host: 'localhost',\n        port: 3003\n      }];\n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n\n      // Try connecting to each server until we find one that works (preferably the leader)\n      for (const server of this.serverList) {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        try {\n          await this.connectToServer(server, serverUrl);\n\n          // If we found the leader, break out of the loop\n          if (this.leaderServer) {\n            break;\n          }\n        } catch (error) {\n          this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n          // Continue trying other servers\n        }\n      }\n      this.initialized = true;\n\n      // If we don't have a connection yet, schedule a retry\n      if (!this.activeSocket && this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      if (this.autoReconnect) {\n        this.scheduleReconnect();\n      } else {\n        throw new Error(`Failed to initialize server connection: ${error.message}`);\n      }\n    }\n  }\n  async connectToServer(server, serverUrl) {\n    this.log(`Connecting to server ${server.id} at ${serverUrl}`);\n\n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false,\n      // We'll handle reconnection manually\n      timeout: 5000\n    });\n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n\n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server ${server.id} at ${serverUrl}`);\n\n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, response => {\n          const isLeader = response && response.isLeader;\n\n          // If this is the leader, use it as the active server\n          if (isLeader) {\n            this.log(`Server ${serverUrl} confirmed as leader`);\n            this.setActiveServer(socket, server, serverUrl);\n            resolve(true);\n          } else {\n            // If the server is not the leader but provides a redirect to leader\n            if (response && response.leaderUrl) {\n              this.log(`Server ${serverUrl} redirected to leader at ${response.leaderUrl}`);\n              socket.disconnect();\n\n              // Try connecting to the leader\n              const leaderParts = response.leaderUrl.split(':');\n              const leaderPort = parseInt(leaderParts[leaderParts.length - 1]);\n              const leaderHost = leaderParts[leaderParts.length - 2].replace(/\\/\\//g, '');\n              const leaderServer = {\n                id: response.leaderId || 0,\n                host: leaderHost,\n                port: leaderPort\n              };\n              resolve(this.connectToServer(leaderServer, response.leaderUrl));\n            } else {\n              // If no leader information, use this server temporarily\n              this.log(`Server ${serverUrl} not a leader, but using it temporarily`);\n              this.setActiveServer(socket, server, serverUrl);\n              resolve(false);\n            }\n          }\n        });\n      });\n\n      // Handle connection error\n      socket.on('connect_error', error => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.log(`Disconnected from ${serverUrl}`);\n\n        // If this was our active socket, try to reconnect\n        if (this.activeSocket === socket) {\n          this.activeSocket = null;\n          this.leaderServer = null;\n\n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'disconnected',\n              message: 'Disconnected from server'\n            });\n          }\n          if (this.autoReconnect) {\n            this.scheduleReconnect();\n          }\n        }\n      });\n    });\n  }\n  setActiveServer(socket, server, serverUrl) {\n    this.activeSocket = socket;\n    this.leaderServer = {\n      id: server.id,\n      url: serverUrl,\n      socket: socket\n    };\n\n    // Forward events from this socket\n    this.forwardEvents(socket);\n\n    // Try to rejoin a room if we have saved session\n    this.attemptRoomRejoin(socket);\n\n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(socket);\n    }\n\n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'connected',\n        server: serverUrl\n      });\n    }\n  }\n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    this.reconnectTimer = setTimeout(async () => {\n      this.log('Attempting to reconnect to servers...');\n\n      // Try each server again\n      for (const server of this.serverList) {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        try {\n          await this.connectToServer(server, serverUrl);\n          if (this.activeSocket) {\n            break; // Successfully reconnected\n          }\n        } catch (error) {\n          // Continue trying next server\n        }\n      }\n\n      // If still not connected, schedule another attempt\n      if (!this.activeSocket && this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    }, this.reconnectInterval);\n  }\n  forwardEvents(socket) {\n    if (!socket) return;\n\n    // Store socket ID when available\n    socket.on('connect', () => {\n      this.socketId = socket.id;\n    });\n\n    // Forward common events from the socket to this event emitter\n    const eventsToForward = ['init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined', 'roomLeft', 'playerJoined', 'playerLeft', 'playerReady', 'gameStarted', 'gameOver', 'error', 'disconnect'];\n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, data => {\n        if (eventName === 'init' && typeof data === 'string') {\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = {\n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        this.emit(eventName, data);\n      });\n    });\n  }\n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId\n      });\n    }\n  }\n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n\n    // Always forward all events to local listeners\n    return super.emit(eventName, data);\n  }\n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  getSocket() {\n    return this.activeSocket;\n  }\n  getSocketId() {\n    return this.socketId;\n  }\n  disconnect() {\n    if (this.activeSocket) {\n      this.activeSocket.disconnect();\n    }\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.initialized = false;\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;","map":{"version":3,"names":["io","EventEmitter","saveGameSession","getGameSession","clearGameSession","ServerConnectionManager","constructor","serverList","activeSocket","leaderServer","socketId","debug","autoReconnect","reconnectInterval","initialized","reconnectTimer","log","message","console","initialize","onConnectedCallback","onStateChangeCallback","id","host","port","length","server","serverUrl","connectToServer","error","scheduleReconnect","Error","socket","reconnection","timeout","Promise","resolve","reject","setTimeout","close","on","clearTimeout","emit","response","isLeader","setActiveServer","leaderUrl","disconnect","leaderParts","split","leaderPort","parseInt","leaderHost","replace","leaderId","type","url","forwardEvents","attemptRoomRejoin","eventsToForward","forEach","eventName","data","parsedData","JSON","parse","e","appPhase","players","activePlayers","readyPlayers","gameInProgress","session","roomCode","playerName","previousSocketId","listener","getSocket","getSocketId","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n    \n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n    \n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  \n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  \n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    \n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    \n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = serverList || [\n        { id: 0, host: 'localhost', port: 3001 },\n        { id: 1, host: 'localhost', port: 3002 },\n        { id: 2, host: 'localhost', port: 3003 }\n      ];\n      \n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n      \n      // Try connecting to each server until we find one that works (preferably the leader)\n      for (const server of this.serverList) {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        try {\n          await this.connectToServer(server, serverUrl);\n          \n          // If we found the leader, break out of the loop\n          if (this.leaderServer) {\n            break;\n          }\n        } catch (error) {\n          this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n          // Continue trying other servers\n        }\n      }\n      \n      this.initialized = true;\n      \n      // If we don't have a connection yet, schedule a retry\n      if (!this.activeSocket && this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      if (this.autoReconnect) {\n        this.scheduleReconnect();\n      } else {\n        throw new Error(`Failed to initialize server connection: ${error.message}`);\n      }\n    }\n  }\n  \n  async connectToServer(server, serverUrl) {\n    this.log(`Connecting to server ${server.id} at ${serverUrl}`);\n    \n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false, // We'll handle reconnection manually\n      timeout: 5000\n    });\n    \n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n      \n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server ${server.id} at ${serverUrl}`);\n        \n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, (response) => {\n          const isLeader = response && response.isLeader;\n          \n          // If this is the leader, use it as the active server\n          if (isLeader) {\n            this.log(`Server ${serverUrl} confirmed as leader`);\n            this.setActiveServer(socket, server, serverUrl);\n            resolve(true);\n          } else {\n            // If the server is not the leader but provides a redirect to leader\n            if (response && response.leaderUrl) {\n              this.log(`Server ${serverUrl} redirected to leader at ${response.leaderUrl}`);\n              socket.disconnect();\n              \n              // Try connecting to the leader\n              const leaderParts = response.leaderUrl.split(':');\n              const leaderPort = parseInt(leaderParts[leaderParts.length - 1]);\n              const leaderHost = leaderParts[leaderParts.length - 2].replace(/\\/\\//g, '');\n              \n              const leaderServer = {\n                id: response.leaderId || 0,\n                host: leaderHost,\n                port: leaderPort\n              };\n              \n              resolve(this.connectToServer(leaderServer, response.leaderUrl));\n            } else {\n              // If no leader information, use this server temporarily\n              this.log(`Server ${serverUrl} not a leader, but using it temporarily`);\n              this.setActiveServer(socket, server, serverUrl);\n              resolve(false);\n            }\n          }\n        });\n      });\n      \n      // Handle connection error\n      socket.on('connect_error', (error) => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n      \n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.log(`Disconnected from ${serverUrl}`);\n        \n        // If this was our active socket, try to reconnect\n        if (this.activeSocket === socket) {\n          this.activeSocket = null;\n          this.leaderServer = null;\n          \n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'disconnected',\n              message: 'Disconnected from server'\n            });\n          }\n          \n          if (this.autoReconnect) {\n            this.scheduleReconnect();\n          }\n        }\n      });\n    });\n  }\n  \n  setActiveServer(socket, server, serverUrl) {\n    this.activeSocket = socket;\n    this.leaderServer = {\n      id: server.id,\n      url: serverUrl,\n      socket: socket\n    };\n    \n    // Forward events from this socket\n    this.forwardEvents(socket);\n    \n    // Try to rejoin a room if we have saved session\n    this.attemptRoomRejoin(socket);\n    \n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(socket);\n    }\n    \n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'connected',\n        server: serverUrl\n      });\n    }\n  }\n  \n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    \n    this.reconnectTimer = setTimeout(async () => {\n      this.log('Attempting to reconnect to servers...');\n      \n      // Try each server again\n      for (const server of this.serverList) {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        try {\n          await this.connectToServer(server, serverUrl);\n          if (this.activeSocket) {\n            break; // Successfully reconnected\n          }\n        } catch (error) {\n          // Continue trying next server\n        }\n      }\n      \n      // If still not connected, schedule another attempt\n      if (!this.activeSocket && this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    }, this.reconnectInterval);\n  }\n  \n  forwardEvents(socket) {\n    if (!socket) return;\n    \n    // Store socket ID when available\n    socket.on('connect', () => {\n      this.socketId = socket.id;\n    });\n    \n    // Forward common events from the socket to this event emitter\n    const eventsToForward = [\n      'init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined',\n      'roomLeft', 'playerJoined', 'playerLeft', 'playerReady',\n      'gameStarted', 'gameOver', 'error', 'disconnect'\n    ];\n    \n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, (data) => {\n        if (eventName === 'init' && typeof data === 'string') {\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = { \n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        \n        this.emit(eventName, data);\n      });\n    });\n  }\n  \n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n      \n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId\n      });\n    }\n  }\n  \n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n    \n    // Always forward all events to local listeners\n    return super.emit(eventName, data);\n  }\n  \n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  \n  getSocket() {\n    return this.activeSocket;\n  }\n  \n  getSocketId() {\n    return this.socketId;\n  }\n  \n  disconnect() {\n    if (this.activeSocket) {\n      this.activeSocket.disconnect();\n    }\n    \n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.initialized = false;\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}