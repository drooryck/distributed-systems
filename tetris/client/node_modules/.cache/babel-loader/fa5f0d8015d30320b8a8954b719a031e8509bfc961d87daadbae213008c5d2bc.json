{"ast":null,"code":"var _jsxFileName = \"/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/GameBoard.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\n\n// Map of tetromino values to colors (TGM2-inspired color scheme)\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst COLORS = {\n  1: {\n    // I - Cyan\n    main: '#00FFFF',\n    light: '#AAFFFF',\n    dark: '#009999'\n  },\n  2: {\n    // J - Blue\n    main: '#0000FF',\n    light: '#9999FF',\n    dark: '#000099'\n  },\n  3: {\n    // L - Orange\n    main: '#FF7700',\n    light: '#FFBB77',\n    dark: '#994700'\n  },\n  4: {\n    // O - Yellow\n    main: '#FFFF00',\n    light: '#FFFFAA',\n    dark: '#999900'\n  },\n  5: {\n    // S - Green\n    main: '#00FF00',\n    light: '#AAFFAA',\n    dark: '#009900'\n  },\n  6: {\n    // T - Purple\n    main: '#AA00FF',\n    light: '#DDAAFF',\n    dark: '#550077'\n  },\n  7: {\n    // Z - Red\n    main: '#FF0000',\n    light: '#FFAAAA',\n    dark: '#990000'\n  }\n};\nfunction GameBoard({\n  board,\n  players,\n  currentPlayerId\n}) {\n  _s();\n  var _board$;\n  const canvasRef = useRef(null);\n  const cellSize = 30; // each cell is 30px\n\n  // Calculate canvas dimensions based on board size\n  const canvasWidth = board !== null && board !== void 0 && (_board$ = board[0]) !== null && _board$ !== void 0 && _board$.length ? board[0].length * cellSize : 300;\n  const canvasHeight = board !== null && board !== void 0 && board.length ? board.length * cellSize : 600;\n\n  // Helper function to draw a TGM2-style block\n  const drawTGMBlock = (ctx, x, y, color) => {\n    const blockColors = typeof color === 'string' ? {\n      main: color,\n      light: '#FFFFFF',\n      dark: '#555555'\n    } : color;\n    const padding = 1; // Space between blocks\n\n    // Background (darker version of the main color)\n    ctx.fillStyle = blockColors.dark;\n    ctx.fillRect(x * cellSize + padding, y * cellSize + padding, cellSize - padding * 2, cellSize - padding * 2);\n\n    // Main color fill (slightly smaller than the full cell)\n    ctx.fillStyle = blockColors.main;\n    ctx.fillRect(x * cellSize + padding + 2, y * cellSize + padding + 2, cellSize - padding * 4, cellSize - padding * 4);\n\n    // Top-left edge highlight (light)\n    ctx.beginPath();\n    ctx.moveTo(x * cellSize + padding, y * cellSize + padding);\n    ctx.lineTo(x * cellSize + cellSize - padding, y * cellSize + padding);\n    ctx.lineTo(x * cellSize + cellSize - padding - 4, y * cellSize + padding + 4);\n    ctx.lineTo(x * cellSize + padding + 4, y * cellSize + padding + 4);\n    ctx.lineTo(x * cellSize + padding + 4, y * cellSize + cellSize - padding - 4);\n    ctx.lineTo(x * cellSize + padding, y * cellSize + cellSize - padding);\n    ctx.closePath();\n    ctx.fillStyle = blockColors.light;\n    ctx.fill();\n\n    // Bottom-right edge shadow (dark)\n    ctx.beginPath();\n    ctx.moveTo(x * cellSize + cellSize - padding, y * cellSize + padding);\n    ctx.lineTo(x * cellSize + cellSize - padding, y * cellSize + cellSize - padding);\n    ctx.lineTo(x * cellSize + padding, y * cellSize + cellSize - padding);\n    ctx.lineTo(x * cellSize + padding + 4, y * cellSize + cellSize - padding - 4);\n    ctx.lineTo(x * cellSize + cellSize - padding - 4, y * cellSize + cellSize - padding - 4);\n    ctx.lineTo(x * cellSize + cellSize - padding - 4, y * cellSize + padding + 4);\n    ctx.closePath();\n    ctx.fillStyle = blockColors.dark;\n    ctx.fill();\n\n    // Small highlight in top-left corner (classic TGM style)\n    ctx.fillStyle = '#FFFFFF';\n    ctx.fillRect(x * cellSize + padding + 3, y * cellSize + padding + 3, 3, 3);\n  };\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw a dark background\n    ctx.fillStyle = '#111';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw the grid (subtle)\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 0.5;\n\n    // Draw grid lines\n    for (let r = 0; r <= board.length; r++) {\n      ctx.beginPath();\n      ctx.moveTo(0, r * cellSize);\n      ctx.lineTo(canvas.width, r * cellSize);\n      ctx.stroke();\n    }\n    for (let c = 0; c <= (((_board$2 = board[0]) === null || _board$2 === void 0 ? void 0 : _board$2.length) || 0); c++) {\n      var _board$2;\n      ctx.beginPath();\n      ctx.moveTo(c * cellSize, 0);\n      ctx.lineTo(c * cellSize, canvas.height);\n      ctx.stroke();\n    }\n\n    // Draw placed pieces on the board\n    for (let r = 0; r < board.length; r++) {\n      if (!board[r]) continue;\n      for (let c = 0; c < board[r].length; c++) {\n        const cell = board[r][c];\n        if (cell !== 0) {\n          // If the cell has a complex structure (from server)\n          if (typeof cell === 'object' && cell !== null) {\n            const playerId = cell.playerId;\n            if (!playerId) {\n              drawTGMBlock(ctx, c, r, {\n                main: 'gray',\n                light: '#AAA',\n                dark: '#444'\n              });\n            } else {\n              const player = Object.values(players || {}).find(p => p && p.id === playerId.substring(0, 4));\n              const color = player ? player.color : 'gray';\n              drawTGMBlock(ctx, c, r, {\n                main: color,\n                light: '#FFFFFF',\n                dark: '#555555'\n              });\n            }\n          } else {\n            // If it's just a number (simple case)\n            drawTGMBlock(ctx, c, r, COLORS[cell] || {\n              main: 'gray',\n              light: '#AAA',\n              dark: '#444'\n            });\n          }\n        }\n      }\n    }\n\n    // Draw line clear animation if active\n    if (board && Array.isArray(board.linesToClear) && board.linesToClear.length > 0) {\n      board.linesToClear.forEach(rowIndex => {\n        // Flash or highlight the rows being cleared\n        const flash = Math.floor(Date.now() / 100) % 2 === 0;\n        ctx.fillStyle = flash ? '#FFFFFF' : '#888888';\n        ctx.fillRect(0, rowIndex * cellSize, canvas.width, cellSize);\n      });\n    }\n\n    // Draw active tetromino for each player\n    if (players && typeof players === 'object') {\n      Object.values(players).forEach(player => {\n        if (!player || !player.currentPiece || !player.currentPiece.shape) return;\n        const {\n          x,\n          y,\n          currentPiece,\n          color\n        } = player;\n        const shape = currentPiece.shape;\n        if (!Array.isArray(shape)) return;\n        for (let r = 0; r < shape.length; r++) {\n          if (!Array.isArray(shape[r])) continue;\n          for (let c = 0; c < shape[r].length; c++) {\n            if (shape[r][c] !== 0) {\n              var _board$3;\n              const boardX = x + c;\n              const boardY = y + r;\n\n              // Skip if out of bounds or above the board\n              if (boardX < 0 || boardX >= (((_board$3 = board[0]) === null || _board$3 === void 0 ? void 0 : _board$3.length) || 0) || boardY < 0 || boardY >= board.length) {\n                continue;\n              }\n\n              // Get the block color based on piece type\n              let blockColor;\n              if (color) {\n                blockColor = {\n                  main: color,\n                  light: '#FFFFFF',\n                  dark: '#555555'\n                };\n              } else if (currentPiece.type && COLORS[shape[r][c]]) {\n                blockColor = COLORS[shape[r][c]];\n              } else {\n                blockColor = {\n                  main: 'gray',\n                  light: '#AAA',\n                  dark: '#444'\n                };\n              }\n              drawTGMBlock(ctx, boardX, boardY, blockColor);\n            }\n          }\n        }\n      });\n    }\n  }, [board, players, currentPlayerId]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: canvasWidth,\n      height: canvasHeight,\n      style: {\n        border: '2px solid #555',\n        borderRadius: '3px',\n        boxShadow: '0 0 15px rgba(0, 0, 0, 0.5)'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 223,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 222,\n    columnNumber: 5\n  }, this);\n}\n_s(GameBoard, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = GameBoard;\nexport default GameBoard;\nvar _c;\n$RefreshReg$(_c, \"GameBoard\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","COLORS","main","light","dark","GameBoard","board","players","currentPlayerId","_s","_board$","canvasRef","cellSize","canvasWidth","length","canvasHeight","drawTGMBlock","ctx","x","y","color","blockColors","padding","fillStyle","fillRect","beginPath","moveTo","lineTo","closePath","fill","canvas","current","getContext","clearRect","width","height","strokeStyle","lineWidth","r","stroke","c","_board$2","cell","playerId","player","Object","values","find","p","id","substring","Array","isArray","linesToClear","forEach","rowIndex","flash","Math","floor","Date","now","currentPiece","shape","_board$3","boardX","boardY","blockColor","type","children","ref","style","border","borderRadius","boxShadow","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/GameBoard.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\n\n// Map of tetromino values to colors (TGM2-inspired color scheme)\nconst COLORS = {\n  1: { // I - Cyan\n    main: '#00FFFF',\n    light: '#AAFFFF',\n    dark: '#009999'\n  },\n  2: { // J - Blue\n    main: '#0000FF',\n    light: '#9999FF',\n    dark: '#000099'\n  },\n  3: { // L - Orange\n    main: '#FF7700',\n    light: '#FFBB77',\n    dark: '#994700'\n  },\n  4: { // O - Yellow\n    main: '#FFFF00',\n    light: '#FFFFAA',\n    dark: '#999900'\n  },\n  5: { // S - Green\n    main: '#00FF00', \n    light: '#AAFFAA',\n    dark: '#009900'\n  },\n  6: { // T - Purple\n    main: '#AA00FF',\n    light: '#DDAAFF',\n    dark: '#550077'\n  },\n  7: { // Z - Red\n    main: '#FF0000',\n    light: '#FFAAAA',\n    dark: '#990000'\n  }\n};\n\nfunction GameBoard({ board, players, currentPlayerId }) {\n  const canvasRef = useRef(null);\n  const cellSize = 30; // each cell is 30px\n  \n  // Calculate canvas dimensions based on board size\n  const canvasWidth = board?.[0]?.length ? board[0].length * cellSize : 300;\n  const canvasHeight = board?.length ? board.length * cellSize : 600;\n\n  // Helper function to draw a TGM2-style block\n  const drawTGMBlock = (ctx, x, y, color) => {\n    const blockColors = typeof color === 'string' \n      ? { main: color, light: '#FFFFFF', dark: '#555555' } \n      : color;\n      \n    const padding = 1; // Space between blocks\n    \n    // Background (darker version of the main color)\n    ctx.fillStyle = blockColors.dark;\n    ctx.fillRect(\n      x * cellSize + padding, \n      y * cellSize + padding, \n      cellSize - padding * 2, \n      cellSize - padding * 2\n    );\n    \n    // Main color fill (slightly smaller than the full cell)\n    ctx.fillStyle = blockColors.main;\n    ctx.fillRect(\n      x * cellSize + padding + 2, \n      y * cellSize + padding + 2, \n      cellSize - padding * 4, \n      cellSize - padding * 4\n    );\n    \n    // Top-left edge highlight (light)\n    ctx.beginPath();\n    ctx.moveTo(x * cellSize + padding, y * cellSize + padding);\n    ctx.lineTo(x * cellSize + cellSize - padding, y * cellSize + padding);\n    ctx.lineTo(x * cellSize + cellSize - padding - 4, y * cellSize + padding + 4);\n    ctx.lineTo(x * cellSize + padding + 4, y * cellSize + padding + 4);\n    ctx.lineTo(x * cellSize + padding + 4, y * cellSize + cellSize - padding - 4);\n    ctx.lineTo(x * cellSize + padding, y * cellSize + cellSize - padding);\n    ctx.closePath();\n    ctx.fillStyle = blockColors.light;\n    ctx.fill();\n    \n    // Bottom-right edge shadow (dark)\n    ctx.beginPath();\n    ctx.moveTo(x * cellSize + cellSize - padding, y * cellSize + padding);\n    ctx.lineTo(x * cellSize + cellSize - padding, y * cellSize + cellSize - padding);\n    ctx.lineTo(x * cellSize + padding, y * cellSize + cellSize - padding);\n    ctx.lineTo(x * cellSize + padding + 4, y * cellSize + cellSize - padding - 4);\n    ctx.lineTo(x * cellSize + cellSize - padding - 4, y * cellSize + cellSize - padding - 4);\n    ctx.lineTo(x * cellSize + cellSize - padding - 4, y * cellSize + padding + 4);\n    ctx.closePath();\n    ctx.fillStyle = blockColors.dark;\n    ctx.fill();\n    \n    // Small highlight in top-left corner (classic TGM style)\n    ctx.fillStyle = '#FFFFFF';\n    ctx.fillRect(\n      x * cellSize + padding + 3, \n      y * cellSize + padding + 3, \n      3, \n      3\n    );\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    \n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw a dark background\n    ctx.fillStyle = '#111';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw the grid (subtle)\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 0.5;\n    \n    // Draw grid lines\n    for (let r = 0; r <= board.length; r++) {\n      ctx.beginPath();\n      ctx.moveTo(0, r * cellSize);\n      ctx.lineTo(canvas.width, r * cellSize);\n      ctx.stroke();\n    }\n    \n    for (let c = 0; c <= (board[0]?.length || 0); c++) {\n      ctx.beginPath();\n      ctx.moveTo(c * cellSize, 0);\n      ctx.lineTo(c * cellSize, canvas.height);\n      ctx.stroke();\n    }\n    \n    // Draw placed pieces on the board\n    for (let r = 0; r < board.length; r++) {\n      if (!board[r]) continue;\n      \n      for (let c = 0; c < board[r].length; c++) {\n        const cell = board[r][c];\n        if (cell !== 0) {\n          // If the cell has a complex structure (from server)\n          if (typeof cell === 'object' && cell !== null) {\n            const playerId = cell.playerId;\n            if (!playerId) {\n              drawTGMBlock(ctx, c, r, { main: 'gray', light: '#AAA', dark: '#444' });\n            } else {\n              const player = Object.values(players || {}).find(p => p && p.id === playerId.substring(0, 4));\n              const color = player ? player.color : 'gray';\n              drawTGMBlock(ctx, c, r, { main: color, light: '#FFFFFF', dark: '#555555' });\n            }\n          } else {\n            // If it's just a number (simple case)\n            drawTGMBlock(ctx, c, r, COLORS[cell] || { main: 'gray', light: '#AAA', dark: '#444' });\n          }\n        }\n      }\n    }\n\n    // Draw line clear animation if active\n    if (board && Array.isArray(board.linesToClear) && board.linesToClear.length > 0) {\n      board.linesToClear.forEach(rowIndex => {\n        // Flash or highlight the rows being cleared\n        const flash = Math.floor(Date.now() / 100) % 2 === 0;\n        ctx.fillStyle = flash ? '#FFFFFF' : '#888888';\n        \n        ctx.fillRect(0, rowIndex * cellSize, canvas.width, cellSize);\n      });\n    }\n      \n    // Draw active tetromino for each player\n    if (players && typeof players === 'object') {\n      Object.values(players).forEach(player => {\n        if (!player || !player.currentPiece || !player.currentPiece.shape) return;\n        \n        const { x, y, currentPiece, color } = player;\n        const shape = currentPiece.shape;\n        \n        if (!Array.isArray(shape)) return;\n        \n        for (let r = 0; r < shape.length; r++) {\n          if (!Array.isArray(shape[r])) continue;\n          \n          for (let c = 0; c < shape[r].length; c++) {\n            if (shape[r][c] !== 0) {\n              const boardX = x + c;\n              const boardY = y + r;\n              \n              // Skip if out of bounds or above the board\n              if (boardX < 0 || boardX >= (board[0]?.length || 0) || \n                  boardY < 0 || boardY >= board.length) {\n                continue;\n              }\n              \n              // Get the block color based on piece type\n              let blockColor;\n              if (color) {\n                blockColor = { main: color, light: '#FFFFFF', dark: '#555555' };\n              } else if (currentPiece.type && COLORS[shape[r][c]]) {\n                blockColor = COLORS[shape[r][c]];\n              } else {\n                blockColor = { main: 'gray', light: '#AAA', dark: '#444' };\n              }\n              \n              drawTGMBlock(ctx, boardX, boardY, blockColor);\n            }\n          }\n        }\n      });\n    }\n    \n  }, [board, players, currentPlayerId]);\n\n  return (\n    <div>\n      <canvas\n        ref={canvasRef}\n        width={canvasWidth}\n        height={canvasHeight}\n        style={{ \n          border: '2px solid #555',\n          borderRadius: '3px',\n          boxShadow: '0 0 15px rgba(0, 0, 0, 0.5)'\n        }}\n      />\n    </div>\n  );\n}\n\nexport default GameBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}