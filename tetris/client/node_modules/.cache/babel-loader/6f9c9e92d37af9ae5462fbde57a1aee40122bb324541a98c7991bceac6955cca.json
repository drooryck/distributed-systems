{"ast":null,"code":"import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\n/**\n * ServerConnectionManager\n * - Connects to multiple tetris servers in the cluster\n * - Discovers the leader server\n * - Maintains connection to the leader\n * - Handles automatic failover to a new leader\n * - Forwards game events to the application\n */\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.connections = {};\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n    this.hasRejoinedRoom = false;\n\n    // Debug logging\n    this.debug = true;\n\n    // Reconnection settings\n    this.reconnectInterval = 3000;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n\n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n\n  /**\n   * Initialize the server connection manager and connect to servers\n   * @param {function} onConnectedCallback - Called when connected to leader\n   * @param {function} onStateChangeCallback - Called when server state changes\n   * @param {Array} serverList - Optional custom server list\n   */\n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    try {\n      var _config$client;\n      // Load server configuration from config.json\n      const config = await this.loadConfig();\n\n      // Use provided server list, config, or default to localhost ports\n      this.serverList = serverList || ((_config$client = config.client) === null || _config$client === void 0 ? void 0 : _config$client.serverAddresses) || [\"http://localhost:3001\", \"http://localhost:3002\", \"http://localhost:3003\"];\n      this.log(`Initializing with ${this.serverList.length} servers: ${this.serverList.join(', ')}`);\n\n      // Connect to all servers to find the leader\n      const connectionPromises = this.serverList.map(serverUrl => this.connectToServer(serverUrl));\n\n      // Wait for all connection attempts (some may fail, that's expected)\n      await Promise.allSettled(connectionPromises);\n      this.initialized = true;\n\n      // If we don't have a leader yet, try a specific check\n      if (!this.leaderServer) {\n        await this.findLeader();\n      }\n\n      // If still no leader, try the first available server\n      if (!this.leaderServer) {\n        this.findFirstAvailableServer();\n      }\n\n      // Set up automatic periodic check for leader changes\n      setInterval(() => this.verifyLeader(), 10000);\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      throw new Error(`Failed to initialize server connection: ${error.message}`);\n    }\n  }\n\n  /**\n   * Load configuration from config.json\n   */\n  async loadConfig() {\n    try {\n      const response = await fetch('/config.json');\n      if (!response.ok) {\n        throw new Error(`Failed to load config: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      this.log(`Config load error: ${error.message}. Using defaults.`);\n      return {\n        client: {\n          serverAddresses: [\"http://localhost:3001\", \"http://localhost:3002\", \"http://localhost:3003\"]\n        }\n      };\n    }\n  }\n\n  /**\n   * Connect to a server by URL\n   * @param {string} serverUrl - The server URL to connect to\n   */\n  async connectToServer(serverUrl) {\n    this.log(`Connecting to server at ${serverUrl}`);\n    const serverId = this.serverList.indexOf(serverUrl);\n\n    // Create connection entry\n    const connection = {\n      id: serverId >= 0 ? serverId : Object.keys(this.connections).length,\n      url: serverUrl,\n      socket: null,\n      isConnected: false,\n      isLeader: false,\n      lastActivity: Date.now()\n    };\n\n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false,\n      // We handle reconnection manually\n      timeout: 5000\n    });\n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n\n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server at ${serverUrl} with ID: ${socket.id}`);\n        connection.socket = socket;\n        connection.isConnected = true;\n        connection.lastActivity = Date.now();\n        this.connections[connection.id] = connection;\n\n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, response => {\n          connection.isLeader = response.isLeader;\n\n          // If this is the leader, use it as the active server\n          if (response.isLeader) {\n            this.log(`Server at ${serverUrl} is the leader (ID: ${response.leaderId})`);\n            this.setActiveLeader(connection);\n          }\n          // If not leader and we're informed about a leader\n          else if (response.leaderAddress) {\n            this.log(`Server at ${serverUrl} reports leader at: ${response.leaderAddress}`);\n            // We might connect to that leader in another connection attempt\n          }\n          resolve(connection);\n        });\n      });\n\n      // Handle connection error\n      socket.on('connect_error', error => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', reason => {\n        this.log(`Disconnected from ${serverUrl}: ${reason}`);\n        connection.isConnected = false;\n\n        // If this was the leader, find a new one\n        if (this.leaderServer === connection) {\n          this.log(`Leader disconnected, finding new leader...`);\n          this.leaderServer = null;\n          this.activeSocket = null;\n\n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'leaderDisconnected',\n              reason\n            });\n          }\n\n          // Try to find a new leader\n          this.findLeader();\n        }\n      });\n    }).catch(error => {\n      this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n      // Don't throw - we just continue with other servers\n    });\n  }\n\n  /**\n   * Find the leader among connected servers\n   */\n  async findLeader() {\n    this.log('Searching for leader server...');\n    const checkLeaderPromises = [];\n\n    // Ask all connected servers if they're the leader\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.isConnected && connection.socket) {\n        const checkPromise = new Promise(resolve => {\n          connection.socket.emit('checkLeader', {}, response => {\n            if (response) {\n              connection.isLeader = response.isLeader;\n              if (response.isLeader) {\n                this.log(`Server ${connection.url} confirmed as leader`);\n                this.setActiveLeader(connection);\n              }\n            }\n            resolve();\n          });\n        });\n        checkLeaderPromises.push(checkPromise);\n      }\n    }\n\n    // Wait for all checks to complete\n    await Promise.all(checkLeaderPromises);\n    return this.leaderServer !== null;\n  }\n\n  /**\n   * Find and use the first available server if no leader\n   */\n  findFirstAvailableServer() {\n    // If no leader found, try the first connected server\n    if (!this.leaderServer) {\n      for (const id in this.connections) {\n        const connection = this.connections[id];\n        if (connection.isConnected) {\n          this.log(`No leader found. Using ${connection.url} as temporary server`);\n          this.setActiveLeader(connection);\n          break;\n        }\n      }\n    }\n\n    // If still no server available, schedule reconnection attempts\n    if (!this.leaderServer) {\n      this.scheduleReconnect();\n    }\n  }\n\n  /**\n   * Schedule reconnection attempts for disconnected servers\n   */\n  scheduleReconnect() {\n    this.reconnectAttempts++;\n    if (this.reconnectAttempts <= this.maxReconnectAttempts) {\n      // Clear any existing reconnect timer\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n\n      // Exponential backoff for reconnect delay\n      const delay = Math.min(this.reconnectInterval * Math.pow(1.5, this.reconnectAttempts - 1), 30000);\n      this.log(`Scheduling reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);\n      this.reconnectTimer = setTimeout(async () => {\n        this.log(`Attempting to reconnect to servers...`);\n\n        // Try to connect to all servers again\n        try {\n          const connectionPromises = this.serverList.map(serverUrl => {\n            // Only reconnect if we don't have an active connection\n            const existingConn = Object.values(this.connections).find(c => c.url === serverUrl && c.isConnected);\n            if (!existingConn) {\n              return this.connectToServer(serverUrl);\n            }\n            return Promise.resolve();\n          });\n          await Promise.allSettled(connectionPromises);\n\n          // Find leader among new connections\n          await this.findLeader();\n\n          // If still no leader, try the first available\n          if (!this.leaderServer) {\n            this.findFirstAvailableServer();\n          }\n        } catch (error) {\n          this.log(`Reconnection attempt failed: ${error.message}`);\n        }\n\n        // If still no leader and not at max attempts, schedule another try\n        if (!this.leaderServer && this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.scheduleReconnect();\n        } else if (!this.leaderServer) {\n          this.log('Max reconnection attempts reached. No available servers.');\n          // Notify about connection failure\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'allServersDown'\n            });\n          }\n        }\n      }, delay);\n    } else {\n      this.log('Max reconnection attempts reached. No available servers.');\n      // Notify about connection failure\n      if (this.onStateChangeCallback) {\n        this.onStateChangeCallback({\n          type: 'allServersDown'\n        });\n      }\n    }\n  }\n\n  /**\n   * Set a connection as the active leader\n   * @param {Object} connection - The connection to use as leader\n   */\n  setActiveLeader(connection) {\n    const wasLeaderChange = this.leaderServer !== connection;\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    this.log(`Setting ${connection.url} as active leader`);\n\n    // Reset reconnect count when we have a leader\n    this.reconnectAttempts = 0;\n\n    // Forward events from this socket\n    this.forwardEvents(connection.socket);\n\n    // Store the socket ID for reference\n    this.socketId = connection.socket.id;\n\n    // Call the connected callback if provided\n    if (wasLeaderChange && this.onConnectedCallback) {\n      this.onConnectedCallback(this.activeSocket);\n    }\n\n    // Notify about server change if we switched leaders\n    if (wasLeaderChange && this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'leaderChanged',\n        server: connection\n      });\n    }\n\n    // Request initial state from new leader\n    connection.socket.emit('requestInitialState');\n\n    // Try to rejoin a room if we have session data\n    this.attemptRoomRejoin(connection.socket);\n  }\n\n  /**\n   * Forward events from socket to this event emitter\n   * @param {Object} socket - The socket to forward events from\n   */\n  forwardEvents(socket) {\n    if (!socket) return;\n\n    // List of events to forward from socket to this event emitter\n    const eventsToForward = ['init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined', 'roomLeft', 'playerJoined', 'playerLeft', 'playerRejoined', 'hostAssigned', 'gameOver', 'error'];\n\n    // Remove any existing listeners to avoid duplicates\n    socket.removeAllListeners();\n\n    // Set connect/disconnect handlers\n    socket.on('connect', () => {\n      this.log(`Socket ${socket.id} connected`);\n      this.socketId = socket.id;\n    });\n    socket.on('disconnect', reason => {\n      this.log(`Socket ${socket.id} disconnected: ${reason}`);\n      this.emit('disconnect', reason);\n    });\n\n    // Forward all game events from socket to this emitter\n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, data => {\n        this.emit(eventName, data);\n      });\n    });\n  }\n\n  /**\n   * Attempt to rejoin a game room on reconnection\n   * @param {Object} socket - The socket to use for room rejoining\n   */\n  attemptRoomRejoin(socket) {\n    if (!socket || this.hasRejoinedRoom) return;\n    const session = getGameSession();\n    if (!session || !session.roomCode) return;\n    this.log(`Attempting to rejoin room ${session.roomCode}`);\n\n    // Send rejoin request\n    socket.emit('rejoinRoom', {\n      roomCode: session.roomCode,\n      playerName: session.playerName,\n      previousSocketId: session.socketId\n    });\n\n    // Listen for successful rejoin\n    const successHandler = data => {\n      this.log(`Successfully rejoined room ${session.roomCode}`);\n      this.hasRejoinedRoom = true;\n\n      // Update session with new socket ID\n      saveGameSession({\n        ...session,\n        socketId: socket.id\n      });\n\n      // Remove these temporary listeners\n      socket.off('roomRejoined', successHandler);\n      socket.off('error', errorHandler);\n    };\n    const errorHandler = error => {\n      this.log(`Failed to rejoin room: ${error.message}`);\n      // Clear the session on error to prevent future failed attempts\n      clearGameSession();\n\n      // Remove temporary listeners\n      socket.off('roomRejoined', successHandler);\n      socket.off('error', errorHandler);\n    };\n\n    // Add temporary listeners\n    socket.once('roomRejoined', successHandler);\n    socket.once('error', errorHandler);\n  }\n\n  /**\n   * Verify the current leader is still the leader\n   */\n  verifyLeader() {\n    if (!this.leaderServer || !this.activeSocket) return;\n\n    // Check the current leader is still active\n    if (!this.activeSocket.connected) {\n      this.log('Leader socket disconnected, finding new leader');\n      this.leaderServer = null;\n      this.activeSocket = null;\n      this.findLeader();\n      return;\n    }\n\n    // Verify current server is still the leader\n    this.activeSocket.emit('checkLeader', {}, response => {\n      if (!response) return;\n      if (!response.isLeader && response.leaderAddress) {\n        this.log(`Current server is no longer leader. New leader at ${response.leaderAddress}`);\n\n        // Try to connect to the new leader if we don't have it already\n        const leaderConn = Object.values(this.connections).find(c => c.url === response.leaderAddress && c.isConnected);\n        if (leaderConn) {\n          // We already have a connection to the new leader, use it\n          this.setActiveLeader(leaderConn);\n        } else {\n          // Connect to the new leader\n          this.connectToServer(response.leaderAddress).then(newConn => {\n            if (newConn && newConn.isLeader) {\n              this.setActiveLeader(newConn);\n            }\n          }).catch(error => {\n            this.log(`Failed to connect to new leader: ${error.message}`);\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the active socket for communication with server\n   * @returns {Object} The active socket\n   */\n  getSocket() {\n    return this.activeSocket;\n  }\n\n  /**\n   * Get the current socket ID\n   * @returns {string} The socket ID\n   */\n  getSocketId() {\n    return this.socketId;\n  }\n\n  /**\n   * Disconnect from all servers\n   */\n  disconnect() {\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.socket) {\n        connection.socket.disconnect();\n      }\n    }\n    this.connections = {};\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.initialized = false;\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n\n  /**\n   * Emit an event to the active server\n   * @param {string} event - The event name\n   * @param {any} data - The data to send\n   */\n  emit(eventName, ...args) {\n    if (eventName === 'newListener' || eventName === 'removeListener') {\n      // These are EventEmitter events, pass to super\n      return super.emit(eventName, ...args);\n    }\n    if (this.activeSocket) {\n      this.activeSocket.emit(eventName, ...args);\n    } else {\n      this.log(`Cannot emit ${eventName}: no active socket`);\n    }\n  }\n\n  /**\n   * Save session data for reconnection\n   * @param {Object} data - Session data to save\n   */\n  saveSessionData(data) {\n    saveGameSession(data);\n  }\n\n  /**\n   * Clear session data\n   */\n  clearSessionData() {\n    clearGameSession();\n  }\n}\n\n// Export singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;","map":{"version":3,"names":["io","EventEmitter","saveGameSession","getGameSession","clearGameSession","ServerConnectionManager","constructor","connections","serverList","activeSocket","leaderServer","socketId","hasRejoinedRoom","debug","reconnectInterval","reconnectAttempts","maxReconnectAttempts","initialized","reconnectTimer","log","message","console","initialize","onConnectedCallback","onStateChangeCallback","_config$client","config","loadConfig","client","serverAddresses","length","join","connectionPromises","map","serverUrl","connectToServer","Promise","allSettled","findLeader","findFirstAvailableServer","setInterval","verifyLeader","error","Error","response","fetch","ok","status","json","serverId","indexOf","connection","id","Object","keys","url","socket","isConnected","isLeader","lastActivity","Date","now","reconnection","timeout","resolve","reject","setTimeout","close","on","clearTimeout","emit","leaderId","setActiveLeader","leaderAddress","reason","type","catch","checkLeaderPromises","checkPromise","push","all","scheduleReconnect","delay","Math","min","pow","existingConn","values","find","c","wasLeaderChange","forwardEvents","server","attemptRoomRejoin","eventsToForward","removeAllListeners","forEach","eventName","data","session","roomCode","playerName","previousSocketId","successHandler","off","errorHandler","once","connected","leaderConn","then","newConn","getSocket","getSocketId","disconnect","args","saveSessionData","clearSessionData","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\n/**\n * ServerConnectionManager\n * - Connects to multiple tetris servers in the cluster\n * - Discovers the leader server\n * - Maintains connection to the leader\n * - Handles automatic failover to a new leader\n * - Forwards game events to the application\n */\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.connections = {};\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n    this.hasRejoinedRoom = false;\n    \n    // Debug logging\n    this.debug = true;\n    \n    // Reconnection settings\n    this.reconnectInterval = 3000;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    \n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  \n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  \n  /**\n   * Initialize the server connection manager and connect to servers\n   * @param {function} onConnectedCallback - Called when connected to leader\n   * @param {function} onStateChangeCallback - Called when server state changes\n   * @param {Array} serverList - Optional custom server list\n   */\n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    \n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    \n    try {\n      // Load server configuration from config.json\n      const config = await this.loadConfig();\n      \n      // Use provided server list, config, or default to localhost ports\n      this.serverList = serverList || config.client?.serverAddresses || [\n        \"http://localhost:3001\",\n        \"http://localhost:3002\", \n        \"http://localhost:3003\"\n      ];\n      \n      this.log(`Initializing with ${this.serverList.length} servers: ${this.serverList.join(', ')}`);\n      \n      // Connect to all servers to find the leader\n      const connectionPromises = this.serverList.map(serverUrl => this.connectToServer(serverUrl));\n      \n      // Wait for all connection attempts (some may fail, that's expected)\n      await Promise.allSettled(connectionPromises);\n      \n      this.initialized = true;\n      \n      // If we don't have a leader yet, try a specific check\n      if (!this.leaderServer) {\n        await this.findLeader();\n      }\n      \n      // If still no leader, try the first available server\n      if (!this.leaderServer) {\n        this.findFirstAvailableServer();\n      }\n      \n      // Set up automatic periodic check for leader changes\n      setInterval(() => this.verifyLeader(), 10000);\n      \n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      throw new Error(`Failed to initialize server connection: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Load configuration from config.json\n   */\n  async loadConfig() {\n    try {\n      const response = await fetch('/config.json');\n      if (!response.ok) {\n        throw new Error(`Failed to load config: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      this.log(`Config load error: ${error.message}. Using defaults.`);\n      return { client: { serverAddresses: [\"http://localhost:3001\", \"http://localhost:3002\", \"http://localhost:3003\"] } };\n    }\n  }\n  \n  /**\n   * Connect to a server by URL\n   * @param {string} serverUrl - The server URL to connect to\n   */\n  async connectToServer(serverUrl) {\n    this.log(`Connecting to server at ${serverUrl}`);\n    \n    const serverId = this.serverList.indexOf(serverUrl);\n    \n    // Create connection entry\n    const connection = {\n      id: serverId >= 0 ? serverId : Object.keys(this.connections).length,\n      url: serverUrl,\n      socket: null,\n      isConnected: false,\n      isLeader: false,\n      lastActivity: Date.now()\n    };\n    \n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false, // We handle reconnection manually\n      timeout: 5000\n    });\n    \n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n      \n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server at ${serverUrl} with ID: ${socket.id}`);\n        \n        connection.socket = socket;\n        connection.isConnected = true;\n        connection.lastActivity = Date.now();\n        \n        this.connections[connection.id] = connection;\n        \n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, (response) => {\n          connection.isLeader = response.isLeader;\n          \n          // If this is the leader, use it as the active server\n          if (response.isLeader) {\n            this.log(`Server at ${serverUrl} is the leader (ID: ${response.leaderId})`);\n            this.setActiveLeader(connection);\n          }\n          // If not leader and we're informed about a leader\n          else if (response.leaderAddress) {\n            this.log(`Server at ${serverUrl} reports leader at: ${response.leaderAddress}`);\n            // We might connect to that leader in another connection attempt\n          }\n          \n          resolve(connection);\n        });\n      });\n      \n      // Handle connection error\n      socket.on('connect_error', (error) => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n      \n      // Handle disconnection\n      socket.on('disconnect', (reason) => {\n        this.log(`Disconnected from ${serverUrl}: ${reason}`);\n        connection.isConnected = false;\n        \n        // If this was the leader, find a new one\n        if (this.leaderServer === connection) {\n          this.log(`Leader disconnected, finding new leader...`);\n          this.leaderServer = null;\n          this.activeSocket = null;\n          \n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'leaderDisconnected',\n              reason\n            });\n          }\n          \n          // Try to find a new leader\n          this.findLeader();\n        }\n      });\n    }).catch(error => {\n      this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n      // Don't throw - we just continue with other servers\n    });\n  }\n  \n  /**\n   * Find the leader among connected servers\n   */\n  async findLeader() {\n    this.log('Searching for leader server...');\n    \n    const checkLeaderPromises = [];\n    \n    // Ask all connected servers if they're the leader\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.isConnected && connection.socket) {\n        const checkPromise = new Promise(resolve => {\n          connection.socket.emit('checkLeader', {}, (response) => {\n            if (response) {\n              connection.isLeader = response.isLeader;\n              if (response.isLeader) {\n                this.log(`Server ${connection.url} confirmed as leader`);\n                this.setActiveLeader(connection);\n              }\n            }\n            resolve();\n          });\n        });\n        \n        checkLeaderPromises.push(checkPromise);\n      }\n    }\n    \n    // Wait for all checks to complete\n    await Promise.all(checkLeaderPromises);\n    \n    return this.leaderServer !== null;\n  }\n  \n  /**\n   * Find and use the first available server if no leader\n   */\n  findFirstAvailableServer() {\n    // If no leader found, try the first connected server\n    if (!this.leaderServer) {\n      for (const id in this.connections) {\n        const connection = this.connections[id];\n        if (connection.isConnected) {\n          this.log(`No leader found. Using ${connection.url} as temporary server`);\n          this.setActiveLeader(connection);\n          break;\n        }\n      }\n    }\n    \n    // If still no server available, schedule reconnection attempts\n    if (!this.leaderServer) {\n      this.scheduleReconnect();\n    }\n  }\n  \n  /**\n   * Schedule reconnection attempts for disconnected servers\n   */\n  scheduleReconnect() {\n    this.reconnectAttempts++;\n    \n    if (this.reconnectAttempts <= this.maxReconnectAttempts) {\n      // Clear any existing reconnect timer\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n      \n      // Exponential backoff for reconnect delay\n      const delay = Math.min(this.reconnectInterval * Math.pow(1.5, this.reconnectAttempts - 1), 30000);\n      \n      this.log(`Scheduling reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);\n      \n      this.reconnectTimer = setTimeout(async () => {\n        this.log(`Attempting to reconnect to servers...`);\n        \n        // Try to connect to all servers again\n        try {\n          const connectionPromises = this.serverList.map(serverUrl => {\n            // Only reconnect if we don't have an active connection\n            const existingConn = Object.values(this.connections).find(c => c.url === serverUrl && c.isConnected);\n            if (!existingConn) {\n              return this.connectToServer(serverUrl);\n            }\n            return Promise.resolve();\n          });\n          \n          await Promise.allSettled(connectionPromises);\n          \n          // Find leader among new connections\n          await this.findLeader();\n          \n          // If still no leader, try the first available\n          if (!this.leaderServer) {\n            this.findFirstAvailableServer();\n          }\n          \n        } catch (error) {\n          this.log(`Reconnection attempt failed: ${error.message}`);\n        }\n        \n        // If still no leader and not at max attempts, schedule another try\n        if (!this.leaderServer && this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.scheduleReconnect();\n        } else if (!this.leaderServer) {\n          this.log('Max reconnection attempts reached. No available servers.');\n          // Notify about connection failure\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'allServersDown'\n            });\n          }\n        }\n      }, delay);\n    } else {\n      this.log('Max reconnection attempts reached. No available servers.');\n      // Notify about connection failure\n      if (this.onStateChangeCallback) {\n        this.onStateChangeCallback({\n          type: 'allServersDown'\n        });\n      }\n    }\n  }\n  \n  /**\n   * Set a connection as the active leader\n   * @param {Object} connection - The connection to use as leader\n   */\n  setActiveLeader(connection) {\n    const wasLeaderChange = this.leaderServer !== connection;\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    \n    this.log(`Setting ${connection.url} as active leader`);\n    \n    // Reset reconnect count when we have a leader\n    this.reconnectAttempts = 0;\n    \n    // Forward events from this socket\n    this.forwardEvents(connection.socket);\n    \n    // Store the socket ID for reference\n    this.socketId = connection.socket.id;\n    \n    // Call the connected callback if provided\n    if (wasLeaderChange && this.onConnectedCallback) {\n      this.onConnectedCallback(this.activeSocket);\n    }\n    \n    // Notify about server change if we switched leaders\n    if (wasLeaderChange && this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'leaderChanged',\n        server: connection\n      });\n    }\n    \n    // Request initial state from new leader\n    connection.socket.emit('requestInitialState');\n    \n    // Try to rejoin a room if we have session data\n    this.attemptRoomRejoin(connection.socket);\n  }\n  \n  /**\n   * Forward events from socket to this event emitter\n   * @param {Object} socket - The socket to forward events from\n   */\n  forwardEvents(socket) {\n    if (!socket) return;\n    \n    // List of events to forward from socket to this event emitter\n    const eventsToForward = [\n      'init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined',\n      'roomLeft', 'playerJoined', 'playerLeft', 'playerRejoined',\n      'hostAssigned', 'gameOver', 'error'\n    ];\n    \n    // Remove any existing listeners to avoid duplicates\n    socket.removeAllListeners();\n    \n    // Set connect/disconnect handlers\n    socket.on('connect', () => {\n      this.log(`Socket ${socket.id} connected`);\n      this.socketId = socket.id; \n    });\n    \n    socket.on('disconnect', (reason) => {\n      this.log(`Socket ${socket.id} disconnected: ${reason}`);\n      this.emit('disconnect', reason);\n    });\n    \n    // Forward all game events from socket to this emitter\n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, (data) => {\n        this.emit(eventName, data);\n      });\n    });\n  }\n  \n  /**\n   * Attempt to rejoin a game room on reconnection\n   * @param {Object} socket - The socket to use for room rejoining\n   */\n  attemptRoomRejoin(socket) {\n    if (!socket || this.hasRejoinedRoom) return;\n    \n    const session = getGameSession();\n    if (!session || !session.roomCode) return;\n    \n    this.log(`Attempting to rejoin room ${session.roomCode}`);\n    \n    // Send rejoin request\n    socket.emit('rejoinRoom', {\n      roomCode: session.roomCode,\n      playerName: session.playerName,\n      previousSocketId: session.socketId\n    });\n    \n    // Listen for successful rejoin\n    const successHandler = (data) => {\n      this.log(`Successfully rejoined room ${session.roomCode}`);\n      this.hasRejoinedRoom = true;\n      \n      // Update session with new socket ID\n      saveGameSession({\n        ...session,\n        socketId: socket.id\n      });\n      \n      // Remove these temporary listeners\n      socket.off('roomRejoined', successHandler);\n      socket.off('error', errorHandler);\n    };\n    \n    const errorHandler = (error) => {\n      this.log(`Failed to rejoin room: ${error.message}`);\n      // Clear the session on error to prevent future failed attempts\n      clearGameSession();\n      \n      // Remove temporary listeners\n      socket.off('roomRejoined', successHandler);\n      socket.off('error', errorHandler);\n    };\n    \n    // Add temporary listeners\n    socket.once('roomRejoined', successHandler);\n    socket.once('error', errorHandler);\n  }\n  \n  /**\n   * Verify the current leader is still the leader\n   */\n  verifyLeader() {\n    if (!this.leaderServer || !this.activeSocket) return;\n    \n    // Check the current leader is still active\n    if (!this.activeSocket.connected) {\n      this.log('Leader socket disconnected, finding new leader');\n      this.leaderServer = null;\n      this.activeSocket = null;\n      this.findLeader();\n      return;\n    }\n    \n    // Verify current server is still the leader\n    this.activeSocket.emit('checkLeader', {}, (response) => {\n      if (!response) return;\n      \n      if (!response.isLeader && response.leaderAddress) {\n        this.log(`Current server is no longer leader. New leader at ${response.leaderAddress}`);\n        \n        // Try to connect to the new leader if we don't have it already\n        const leaderConn = Object.values(this.connections).find(c => \n          c.url === response.leaderAddress && c.isConnected);\n          \n        if (leaderConn) {\n          // We already have a connection to the new leader, use it\n          this.setActiveLeader(leaderConn);\n        } else {\n          // Connect to the new leader\n          this.connectToServer(response.leaderAddress)\n            .then(newConn => {\n              if (newConn && newConn.isLeader) {\n                this.setActiveLeader(newConn);\n              }\n            })\n            .catch(error => {\n              this.log(`Failed to connect to new leader: ${error.message}`);\n            });\n        }\n      }\n    });\n  }\n  \n  /**\n   * Get the active socket for communication with server\n   * @returns {Object} The active socket\n   */\n  getSocket() {\n    return this.activeSocket;\n  }\n  \n  /**\n   * Get the current socket ID\n   * @returns {string} The socket ID\n   */\n  getSocketId() {\n    return this.socketId;\n  }\n  \n  /**\n   * Disconnect from all servers\n   */\n  disconnect() {\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.socket) {\n        connection.socket.disconnect();\n      }\n    }\n    \n    this.connections = {};\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.initialized = false;\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n  \n  /**\n   * Emit an event to the active server\n   * @param {string} event - The event name\n   * @param {any} data - The data to send\n   */\n  emit(eventName, ...args) {\n    if (eventName === 'newListener' || eventName === 'removeListener') {\n      // These are EventEmitter events, pass to super\n      return super.emit(eventName, ...args);\n    }\n    \n    if (this.activeSocket) {\n      this.activeSocket.emit(eventName, ...args);\n    } else {\n      this.log(`Cannot emit ${eventName}: no active socket`);\n    }\n  }\n  \n  /**\n   * Save session data for reconnection\n   * @param {Object} data - Session data to save\n   */\n  saveSessionData(data) {\n    saveGameSession(data);\n  }\n  \n  /**\n   * Clear session data\n   */\n  clearSessionData() {\n    clearGameSession();\n  }\n}\n\n// Export singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}