{"ast":null,"code":"import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.connections = {};\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n    this.hasRejoinedRoom = false;\n\n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n\n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = serverList || [{\n        id: 0,\n        host: 'localhost',\n        port: 3001\n      }, {\n        id: 1,\n        host: 'localhost',\n        port: 3002\n      }, {\n        id: 2,\n        host: 'localhost',\n        port: 3003\n      }];\n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n\n      // Connect to all available servers\n      const connectionPromises = this.serverList.map(server => {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        return this.connectToServer(server, serverUrl);\n      });\n\n      // Wait for all connection attempts (some may fail, that's expected)\n      await Promise.allSettled(connectionPromises);\n      this.initialized = true;\n\n      // If we don't have a leader yet, try a specific check\n      if (!this.leaderServer) {\n        await this.findLeader();\n      }\n\n      // If still no leader, try the first available server\n      if (!this.leaderServer) {\n        this.findFirstAvailableServer();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      throw new Error(`Failed to initialize server connection: ${error.message}`);\n    }\n  }\n  async connectToServer(server, serverUrl) {\n    this.log(`Connecting to server ${server.id} at ${serverUrl}`);\n\n    // Create connection entry\n    const connection = {\n      id: server.id,\n      url: serverUrl,\n      config: server,\n      socket: null,\n      isConnected: false,\n      isLeader: false,\n      lastActivity: Date.now()\n    };\n\n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false,\n      // We'll handle reconnection manually\n      timeout: 5000\n    });\n    connection.socket = socket;\n    this.connections[server.id] = connection;\n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n\n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server ${server.id} at ${serverUrl}`);\n        connection.isConnected = true;\n        connection.lastActivity = Date.now();\n\n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, response => {\n          connection.isLeader = response.isLeader;\n\n          // If this is the leader, use it as the active server\n          if (response.isLeader && !this.leaderServer) {\n            this.setActiveLeader(connection);\n          }\n          resolve(connection);\n        });\n      });\n\n      // Handle connection error\n      socket.on('connect_error', error => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.log(`Disconnected from ${serverUrl}`);\n        connection.isConnected = false;\n\n        // If this was the leader, find a new one\n        if (this.leaderServer === connection) {\n          this.log(`Leader disconnected, finding new leader...`);\n          this.leaderServer = null;\n          this.activeSocket = null;\n\n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'leaderDisconnected'\n            });\n          }\n\n          // Try to find a new leader\n          this.findLeader();\n        }\n      });\n    }).catch(error => {\n      this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n      // Don't throw - we just continue with other servers\n    });\n  }\n  async findLeader() {\n    this.log('Searching for leader server...');\n    const checkLeaderPromises = [];\n\n    // Ask all connected servers if they're the leader\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.isConnected && connection.socket) {\n        const checkPromise = new Promise(resolve => {\n          connection.socket.emit('checkLeader', {}, response => {\n            if (response) {\n              connection.isLeader = response.isLeader;\n              if (response.isLeader) {\n                this.log(`Server ${connection.url} confirmed as leader`);\n                this.setActiveLeader(connection);\n              }\n            }\n            resolve();\n          });\n        });\n        checkLeaderPromises.push(checkPromise);\n      }\n    }\n\n    // Wait for all checks to complete\n    await Promise.all(checkLeaderPromises);\n    return this.leaderServer !== null;\n  }\n  findFirstAvailableServer() {\n    // If no leader found, try the first connected server\n    if (!this.leaderServer) {\n      for (const id in this.connections) {\n        const connection = this.connections[id];\n        if (connection.isConnected) {\n          this.log(`No leader found. Using ${connection.url} as temporary server`);\n          this.setActiveLeader(connection);\n          break;\n        }\n      }\n    }\n\n    // If still no server available, schedule reconnection attempts\n    if (!this.leaderServer && this.autoReconnect) {\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n      this.reconnectTimer = setTimeout(() => {\n        this.log('No servers available, attempting to reconnect...');\n\n        // Try to connect to all servers again\n        for (const server of this.serverList) {\n          const serverUrl = `http://${server.host}:${server.port}`;\n          this.connectToServer(server, serverUrl).catch(() => {}); // Ignore errors, we'll handle them in the connection promise\n        }\n\n        // Check again if we found a leader\n        setTimeout(() => {\n          if (!this.leaderServer) {\n            this.findLeader();\n          }\n\n          // If still no leader, continue trying the first available\n          if (!this.leaderServer) {\n            this.findFirstAvailableServer();\n          }\n        }, 1000);\n      }, this.reconnectInterval);\n    }\n  }\n  setActiveLeader(connection) {\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    this.log(`Active leader set to ${connection.url}`);\n\n    // Forward events from this socket\n    this.forwardEvents(connection.socket);\n\n    // Request initial state\n    connection.socket.emit('requestInitialState');\n\n    // Try to rejoin a room if we have saved session\n    this.attemptRoomRejoin(connection.socket);\n\n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(this.activeSocket);\n    }\n\n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'leaderChanged',\n        server: connection\n      });\n    }\n  }\n  forwardEvents(socket) {\n    if (!socket) return;\n\n    // Store socket ID when available\n    socket.on('connect', () => {\n      this.socketId = socket.id;\n    });\n\n    // Forward common events from the socket to this event emitter\n    const eventsToForward = ['init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined', 'roomLeft', 'playerJoined', 'playerLeft', 'playerReady', 'gameStarted', 'gameOver', 'error', 'disconnect'];\n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, data => {\n        // Add debug logging to see what data is received\n        console.log(`[DEBUG] Received ${eventName} event with data:`, typeof data, data);\n\n        // Make sure we're receiving an object for the init event\n        if (eventName === 'init' && typeof data === 'string') {\n          console.warn(`[DEBUG] Received init event with string instead of object: \"${data}\"`);\n          // Try to convert if it's a stringified JSON\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = {\n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        this.emit(eventName, data);\n      });\n    });\n  }\n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId\n      });\n    }\n  }\n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n\n    // Always forward all events to local listeners - use the actual data parameter\n    return super.emit(eventName, data);\n  }\n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  getSocket() {\n    return this.activeSocket;\n  }\n  getSocketId() {\n    return this.socketId;\n  }\n  disconnect() {\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.socket) {\n        connection.socket.disconnect();\n      }\n    }\n    this.connections = {};\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.initialized = false;\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;","map":{"version":3,"names":["io","EventEmitter","saveGameSession","getGameSession","clearGameSession","ServerConnectionManager","constructor","connections","serverList","activeSocket","leaderServer","socketId","hasRejoinedRoom","debug","autoReconnect","reconnectInterval","initialized","reconnectTimer","log","message","console","initialize","onConnectedCallback","onStateChangeCallback","id","host","port","length","connectionPromises","map","server","serverUrl","connectToServer","Promise","allSettled","findLeader","findFirstAvailableServer","error","Error","connection","url","config","socket","isConnected","isLeader","lastActivity","Date","now","reconnection","timeout","resolve","reject","setTimeout","close","on","clearTimeout","emit","response","setActiveLeader","type","catch","checkLeaderPromises","checkPromise","push","all","forwardEvents","attemptRoomRejoin","eventsToForward","forEach","eventName","data","warn","parsedData","JSON","parse","e","appPhase","players","activePlayers","readyPlayers","gameInProgress","session","roomCode","playerName","previousSocketId","listener","getSocket","getSocketId","disconnect","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.connections = {};\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n    this.hasRejoinedRoom = false;\n    \n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n    \n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  \n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  \n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    \n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    \n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = serverList || [\n        { id: 0, host: 'localhost', port: 3001 },\n        { id: 1, host: 'localhost', port: 3002 },\n        { id: 2, host: 'localhost', port: 3003 }\n      ];\n      \n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n      \n      // Connect to all available servers\n      const connectionPromises = this.serverList.map(server => {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        return this.connectToServer(server, serverUrl);\n      });\n      \n      // Wait for all connection attempts (some may fail, that's expected)\n      await Promise.allSettled(connectionPromises);\n      \n      this.initialized = true;\n      \n      // If we don't have a leader yet, try a specific check\n      if (!this.leaderServer) {\n        await this.findLeader();\n      }\n      \n      // If still no leader, try the first available server\n      if (!this.leaderServer) {\n        this.findFirstAvailableServer();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      throw new Error(`Failed to initialize server connection: ${error.message}`);\n    }\n  }\n  \n  async connectToServer(server, serverUrl) {\n    this.log(`Connecting to server ${server.id} at ${serverUrl}`);\n    \n    // Create connection entry\n    const connection = {\n      id: server.id,\n      url: serverUrl,\n      config: server,\n      socket: null,\n      isConnected: false,\n      isLeader: false,\n      lastActivity: Date.now()\n    };\n    \n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false, // We'll handle reconnection manually\n      timeout: 5000\n    });\n    \n    connection.socket = socket;\n    this.connections[server.id] = connection;\n    \n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n      \n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server ${server.id} at ${serverUrl}`);\n        connection.isConnected = true;\n        connection.lastActivity = Date.now();\n        \n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, (response) => {\n          connection.isLeader = response.isLeader;\n          \n          // If this is the leader, use it as the active server\n          if (response.isLeader && !this.leaderServer) {\n            this.setActiveLeader(connection);\n          }\n          \n          resolve(connection);\n        });\n      });\n      \n      // Handle connection error\n      socket.on('connect_error', (error) => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n      \n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.log(`Disconnected from ${serverUrl}`);\n        connection.isConnected = false;\n        \n        // If this was the leader, find a new one\n        if (this.leaderServer === connection) {\n          this.log(`Leader disconnected, finding new leader...`);\n          this.leaderServer = null;\n          this.activeSocket = null;\n          \n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'leaderDisconnected'\n            });\n          }\n          \n          // Try to find a new leader\n          this.findLeader();\n        }\n      });\n    }).catch(error => {\n      this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n      // Don't throw - we just continue with other servers\n    });\n  }\n  \n  async findLeader() {\n    this.log('Searching for leader server...');\n    \n    const checkLeaderPromises = [];\n    \n    // Ask all connected servers if they're the leader\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.isConnected && connection.socket) {\n        const checkPromise = new Promise(resolve => {\n          connection.socket.emit('checkLeader', {}, (response) => {\n            if (response) {\n              connection.isLeader = response.isLeader;\n              if (response.isLeader) {\n                this.log(`Server ${connection.url} confirmed as leader`);\n                this.setActiveLeader(connection);\n              }\n            }\n            resolve();\n          });\n        });\n        \n        checkLeaderPromises.push(checkPromise);\n      }\n    }\n    \n    // Wait for all checks to complete\n    await Promise.all(checkLeaderPromises);\n    \n    return this.leaderServer !== null;\n  }\n  \n  findFirstAvailableServer() {\n    // If no leader found, try the first connected server\n    if (!this.leaderServer) {\n      for (const id in this.connections) {\n        const connection = this.connections[id];\n        if (connection.isConnected) {\n          this.log(`No leader found. Using ${connection.url} as temporary server`);\n          this.setActiveLeader(connection);\n          break;\n        }\n      }\n    }\n    \n    // If still no server available, schedule reconnection attempts\n    if (!this.leaderServer && this.autoReconnect) {\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n      \n      this.reconnectTimer = setTimeout(() => {\n        this.log('No servers available, attempting to reconnect...');\n        \n        // Try to connect to all servers again\n        for (const server of this.serverList) {\n          const serverUrl = `http://${server.host}:${server.port}`;\n          this.connectToServer(server, serverUrl)\n            .catch(() => {}); // Ignore errors, we'll handle them in the connection promise\n        }\n        \n        // Check again if we found a leader\n        setTimeout(() => {\n          if (!this.leaderServer) {\n            this.findLeader();\n          }\n          \n          // If still no leader, continue trying the first available\n          if (!this.leaderServer) {\n            this.findFirstAvailableServer();\n          }\n        }, 1000);\n      }, this.reconnectInterval);\n    }\n  }\n  \n  setActiveLeader(connection) {\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    this.log(`Active leader set to ${connection.url}`);\n    \n    // Forward events from this socket\n    this.forwardEvents(connection.socket);\n    \n    // Request initial state\n    connection.socket.emit('requestInitialState');\n    \n    // Try to rejoin a room if we have saved session\n    this.attemptRoomRejoin(connection.socket);\n    \n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(this.activeSocket);\n    }\n    \n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'leaderChanged',\n        server: connection\n      });\n    }\n  }\n  \n  forwardEvents(socket) {\n    if (!socket) return;\n    \n    // Store socket ID when available\n    socket.on('connect', () => {\n      this.socketId = socket.id;\n    });\n    \n    // Forward common events from the socket to this event emitter\n    const eventsToForward = [\n      'init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined',\n      'roomLeft', 'playerJoined', 'playerLeft', 'playerReady',\n      'gameStarted', 'gameOver', 'error', 'disconnect'\n    ];\n    \n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, (data) => {\n        // Add debug logging to see what data is received\n        console.log(`[DEBUG] Received ${eventName} event with data:`, typeof data, data);\n        \n        // Make sure we're receiving an object for the init event\n        if (eventName === 'init' && typeof data === 'string') {\n          console.warn(`[DEBUG] Received init event with string instead of object: \"${data}\"`);\n          // Try to convert if it's a stringified JSON\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = { \n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        \n        this.emit(eventName, data);\n      });\n    });\n  }\n  \n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n      \n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId\n      });\n    }\n  }\n  \n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n    \n    // Always forward all events to local listeners - use the actual data parameter\n    return super.emit(eventName, data);\n  }\n  \n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  \n  getSocket() {\n    return this.activeSocket;\n  }\n  \n  getSocketId() {\n    return this.socketId;\n  }\n  \n  disconnect() {\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.socket) {\n        connection.socket.disconnect();\n      }\n    }\n    \n    this.connections = {};\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.initialized = false;\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}