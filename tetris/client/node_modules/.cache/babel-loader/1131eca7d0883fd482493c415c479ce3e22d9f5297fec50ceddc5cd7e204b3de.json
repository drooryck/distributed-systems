{"ast":null,"code":"import React,{useEffect,useState,useCallback,useRef}from'react';import{io}from'socket.io-client';import{connectToCluster}from'./serverDiscovery';import BoardStage from'./BoardStage';import NewHomeScreen from'./NewHomeScreen';import ReadyScreen from'./ReadyScreen';import GameOverScreen from'./GameOverScreen';import ScorePanel from'./ScorePanel';import'./App.css';// Background image configuration\nimport{jsx as _jsx,jsxs as _jsxs,Fragment as _Fragment}from\"react/jsx-runtime\";const BACKGROUND_IMAGES=['deep-tetris-color.jpg','tetris-1920-x-1080-background-hyihqau5t3lalo4e.png','tetris-2560-x-1600-background-3bjbi7nyulqbller.jpg'];const BACKGROUND_CHANGE_INTERVAL=30000;// 30 seconds\n// Load config file to get server address\nconst loadConfig=async()=>{try{const response=await fetch('/config.json');if(!response.ok){throw new Error(`Failed to load config: ${response.status}`);}return await response.json();}catch(error){console.warn('Error loading config, using default server address:',error);return{serverAddress:'http://localhost:3001'};}};// Debug logging\nconst DEBUG={events:true,state:true,render:false};function debugLog(type){if(DEBUG[type]){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}console.log(`[DEBUG:${type}]`,...args);}}// Function to get current background URL\nconst getBackgroundUrl=index=>{return`${process.env.PUBLIC_URL}/backgrounds/${BACKGROUND_IMAGES[index]}`;};// App component\nfunction App(){const[socket,setSocket]=useState(null);const[gameState,setGameState]=useState(null);const[isGameOver,setIsGameOver]=useState(false);const[gameOverData,setGameOverData]=useState(null);const[isConnecting,setIsConnecting]=useState(true);const[error,setError]=useState(null);const[socketError,setSocketError]=useState(null);// Hard‐drop guard so holding space won't repeat\nconst hardDropActiveRef=useRef(false);// Add state for background rotation\nconst[currentBackgroundIndex,setCurrentBackgroundIndex]=useState(0);const backgroundIntervalRef=useRef(null);// Add state for timer and scoring\nconst[elapsedTime,setElapsedTime]=useState(0);const[currentScore,setCurrentScore]=useState(0);const[lastScoreChange,setLastScoreChange]=useState(0);const[level,setLevel]=useState(1);const timerIntervalRef=useRef(null);// For reconnection logic\nconst reconnectTimeoutRef=useRef(null);const reconnectionAttemptsRef=useRef(0);const MAX_RECONNECT_ATTEMPTS=5;const lastGameStateRef=useRef(null);// Function to get current background URL\nconst getCurrentBackgroundUrl=()=>{return getBackgroundUrl(currentBackgroundIndex);};// Connect to socket on component mount\nuseEffect(()=>{const connectToServer=async()=>{try{setIsConnecting(true);setSocketError(null);const currentUrl=window.location.origin;// Try to connect to the cluster\nlet newSocket;try{debugLog('events','Attempting to connect to server cluster');newSocket=await connectToCluster(currentUrl);}catch(clusterError){var _config$client;debugLog('events','Cluster connection failed, falling back to direct connection',clusterError);// Fall back to direct connection\nconst config=await loadConfig();const serverAddress=((_config$client=config.client)===null||_config$client===void 0?void 0:_config$client.serverAddress)||config.serverAddress||'http://localhost:3001';debugLog('events','Connecting to server:',serverAddress);newSocket=io(serverAddress);}setSocket(newSocket);// Socket event handlers\nnewSocket.on('connect',()=>{debugLog('events','Socket connected with ID:',newSocket.id);setIsConnecting(false);setSocketError(null);reconnectionAttemptsRef.current=0;});newSocket.on('connect_error',err=>{debugLog('events','Connection error:',err.message);setSocketError(`Connection error: ${err.message}`);setIsConnecting(false);});// Handle leader information updates\nnewSocket.on('leaderInfo',info=>{debugLog('events','Leader info received:',info);if(!info.isLeader&&info.leaderAddress){debugLog('events','Redirecting to leader at:',info.leaderAddress);// Disconnect from current socket\nnewSocket.disconnect();// Connect to the leader\nconst leaderSocket=io(info.leaderAddress);// Set up all event handlers on the new socket\nleaderSocket.on('connect',()=>{debugLog('events','Connected to leader with ID:',leaderSocket.id);setIsConnecting(false);setSocketError(null);reconnectionAttemptsRef.current=0;});leaderSocket.on('gameState',newGameState=>{debugLog('state','Received gameState from leader:',newGameState);setGameState(newGameState);// Update score if available\nif(newGameState&&newGameState.appPhase==='playing'){const player=newGameState.players[leaderSocket.id];if(player){const newScore=player.score||0;if(newScore!==currentScore){setLastScoreChange(Date.now());setCurrentScore(newScore);}}}});leaderSocket.on('disconnect',reason=>{debugLog('events','Disconnected from leader:',reason);// Add reconnection logic here if needed\n});// Add other necessary event handlers\nleaderSocket.on('init',initialState=>{debugLog('events','Received init from leader:',initialState);});leaderSocket.on('error',err=>{debugLog('events','Leader socket error:',err);setError(err.message);});// Set the socket state to the new leader socket\nsetSocket(leaderSocket);}});// Handle initial state\nnewSocket.on('init',initialState=>{debugLog('events','Received init event with state:',initialState);// Apply initial state as gameState so UI can render homescreen\nsetGameState({appPhase:initialState.appPhase,players:{},roomCode:null,activePlayers:[],readyPlayers:[]});});// Handle game state updates\nnewSocket.on('gameState',newGameState=>{debugLog('state','Received gameState update:',newGameState);setGameState(prevState=>{// Store the game state for potential reconnection\nif(newGameState){lastGameStateRef.current=newGameState;}// Special case to prevent accidentally going back to homescreen\nif((prevState===null||prevState===void 0?void 0:prevState.appPhase)==='readyscreen'&&(newGameState===null||newGameState===void 0?void 0:newGameState.appPhase)==='homescreen'){debugLog('state','Ignoring homescreen gameState while in readyscreen');return prevState;}return newGameState;});// Update score if available\nif(newGameState&&newGameState.appPhase==='playing'){// Find the player that corresponds to this client\nconst player=newGameState.players[newSocket.id];if(player){const newScore=player.score||0;if(newScore!==currentScore){setLastScoreChange(Date.now());setCurrentScore(newScore);}}}});// Handle room creation\nnewSocket.on('roomCreated',_ref=>{let{roomCode,gameState}=_ref;debugLog('events',`Room created: ${roomCode}`);setGameState(gameState);});// Handle joining a room\nnewSocket.on('roomJoined',_ref2=>{let{roomCode,gameState}=_ref2;debugLog('events',`Joined room: ${roomCode}`);setGameState(gameState);});// Handle player joining\nnewSocket.on('playerJoined',_ref3=>{let{playerId,gameState}=_ref3;debugLog('events',`Player joined: ${playerId}`);setGameState(gameState);});// Handle player leaving\nnewSocket.on('playerLeft',_ref4=>{let{playerId,gameState}=_ref4;debugLog('events',`Player left: ${playerId}`);setGameState(gameState);});// Handle host assignment (when previous host leaves)\nnewSocket.on('hostAssigned',_ref5=>{let{gameState}=_ref5;debugLog('events','You are now the host');setGameState(gameState);});// Handle game over\nnewSocket.on('gameOver',data=>{debugLog('events','Game over:',data);setIsGameOver(true);setGameOverData(data);});// Handle server errors\nnewSocket.on('error',err=>{debugLog('events','Server error:',err);setError(err.message);});// Handle disconnection with reconnection logic\nnewSocket.on('disconnect',reason=>{debugLog('events','Socket disconnected:',reason);// If the disconnect was not initiated by the client, attempt to reconnect\nif(reason==='io server disconnect'||reason==='transport close'||reason==='transport error'){if(reconnectionAttemptsRef.current<MAX_RECONNECT_ATTEMPTS){debugLog('events',`Attempting to reconnect (${reconnectionAttemptsRef.current+1}/${MAX_RECONNECT_ATTEMPTS})...`);setIsConnecting(true);// Clear any existing reconnection timeout\nif(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}// Exponential backoff for reconnection\nconst delay=Math.min(1000*Math.pow(2,reconnectionAttemptsRef.current),10000);reconnectTimeoutRef.current=setTimeout(async()=>{reconnectionAttemptsRef.current++;connectToServer();},delay);}else{debugLog('events','Max reconnection attempts reached');setSocketError('Could not reconnect to the server. Please refresh the page.');setIsConnecting(false);}}});// Return cleanup function\nreturn()=>{debugLog('events','Cleaning up socket connection');if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}newSocket.disconnect();};}catch(err){console.error('Error connecting to server:',err);setSocketError(`Error connecting to server: ${err.message}`);setIsConnecting(false);}};connectToServer();},[]);// Background rotation effect - only active during gameplay\nuseEffect(()=>{// Clear any existing background rotation interval\nif(backgroundIntervalRef.current){clearInterval(backgroundIntervalRef.current);backgroundIntervalRef.current=null;}// Start background rotation when game is playing\nif(gameState&&gameState.appPhase==='playing'){backgroundIntervalRef.current=setInterval(()=>{setCurrentBackgroundIndex(prevIndex=>(prevIndex+1)%BACKGROUND_IMAGES.length);},BACKGROUND_CHANGE_INTERVAL);}return()=>{if(backgroundIntervalRef.current){clearInterval(backgroundIntervalRef.current);}};},[gameState===null||gameState===void 0?void 0:gameState.appPhase]);// Timer effect for gameplay\nuseEffect(()=>{if(gameState&&gameState.appPhase==='playing'){if(!timerIntervalRef.current){const startTime=Date.now();timerIntervalRef.current=setInterval(()=>{const elapsed=Math.floor((Date.now()-startTime)/1000);setElapsedTime(elapsed);// Update level based on time (every 30 seconds)\nconst newLevel=Math.max(1,Math.floor(elapsed/30)+1);if(newLevel!==level){setLevel(newLevel);}},1000);}}else{// Clear timer when not playing\nif(timerIntervalRef.current){clearInterval(timerIntervalRef.current);timerIntervalRef.current=null;}// Reset timer and level when game ends\nif(gameState&&gameState.appPhase!=='playing'){setElapsedTime(0);setLevel(1);}}return()=>{if(timerIntervalRef.current){clearInterval(timerIntervalRef.current);}};},[gameState===null||gameState===void 0?void 0:gameState.appPhase,level]);// Handle keydown events for gameplay\nconst handleKeyDown=useCallback(e=>{if(!socket||!gameState||gameState.appPhase!=='playing')return;// Prevent default behavior for game controls\nif(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','KeyZ'].includes(e.code)){e.preventDefault();}// Only handle keys that aren't being repeated (except down)\nif(!e.repeat||e.code==='ArrowDown'){switch(e.code){case'ArrowLeft':// First send immediate move, then start DAS\nsocket.emit('playerAction',{type:'moveLeft'});socket.emit('playerAction',{type:'startDAS',direction:'left'});break;case'ArrowRight':// First send immediate move, then start DAS\nsocket.emit('playerAction',{type:'moveRight'});socket.emit('playerAction',{type:'startDAS',direction:'right'});break;case'ArrowUp':case'KeyZ':socket.emit('playerAction',{type:'rotate'});break;case'ArrowDown':socket.emit('playerAction',{type:'softDrop'});break;case'Space':// guard against auto‑repeat when holding space\nif(!hardDropActiveRef.current){socket.emit('playerAction',{type:'hardDrop'});hardDropActiveRef.current=true;}break;default:break;}}},[socket,gameState]);// Handle keyup events to stop DAS (delayed auto-shift)\nconst handleKeyUp=useCallback(e=>{if(!socket||!gameState||gameState.appPhase!=='playing')return;switch(e.code){case'ArrowLeft':case'ArrowRight':socket.emit('playerAction',{type:'stopDAS'});break;case'Space':hardDropActiveRef.current=false;break;default:break;}},[socket,gameState]);// Add key event listeners\nuseEffect(()=>{window.addEventListener('keydown',handleKeyDown);window.addEventListener('keyup',handleKeyUp);return()=>{window.removeEventListener('keydown',handleKeyDown);window.removeEventListener('keyup',handleKeyUp);};},[handleKeyDown,handleKeyUp]);// Ensure room events are handled on each socket reconnect\nuseEffect(()=>{if(!socket)return;socket.on('roomCreated',_ref6=>{let{roomCode,gameState}=_ref6;debugLog('events',`Room created: ${roomCode}`);setGameState(gameState);});socket.on('roomJoined',_ref7=>{let{roomCode,gameState}=_ref7;debugLog('events',`Joined room: ${roomCode}`);setGameState(gameState);});return()=>{socket.off('roomCreated');socket.off('roomJoined');};},[socket]);// Create a room\nconst createRoom=useCallback(playerName=>{if(socket){debugLog('events','Creating room with player name:',playerName);socket.emit('createRoom',playerName);}},[socket]);// Join a room\nconst joinRoom=useCallback((roomCode,playerName)=>{if(socket){debugLog('events',`Joining room ${roomCode} with player name: ${playerName}`);socket.emit('joinRoom',{roomCode,playerName});}},[socket]);// Leave a room\nconst leaveRoom=useCallback(()=>{if(socket){debugLog('events','Leaving room');socket.emit('leaveRoom');}},[socket]);// Set player ready state\nconst setReady=useCallback(isReady=>{if(socket){debugLog('events',`Setting ready state: ${isReady}`);socket.emit('playerReady',isReady);}},[socket]);// Start the game (host only)\nconst startGame=useCallback(()=>{if(socket){debugLog('events','Starting game');socket.emit('startGame');}},[socket]);// Show error message if there's a socket error\nif(socketError){return/*#__PURE__*/_jsxs(\"div\",{className:\"App error-screen\",children:[/*#__PURE__*/_jsx(\"h1\",{children:\"Connection Error\"}),/*#__PURE__*/_jsx(\"p\",{children:socketError}),/*#__PURE__*/_jsx(\"p\",{children:\"Please check that the server is running and the configuration is correct.\"}),/*#__PURE__*/_jsx(\"button\",{onClick:()=>window.location.reload(),style:{padding:'10px 20px',backgroundColor:'#FF5733',border:'none',borderRadius:'4px',color:'white',cursor:'pointer',marginTop:'20px'},children:\"Retry Connection\"})]});}// Show loading screen if no game state\nif(!gameState){return/*#__PURE__*/_jsx(\"div\",{className:\"App\",children:/*#__PURE__*/_jsx(\"h1\",{children:\"Waiting for game state...\"})});}// Render appropriate screen based on app phase\nreturn/*#__PURE__*/_jsxs(\"div\",{className:\"App\",style:{...(gameState.appPhase==='playing'&&{backgroundImage:`url(${getCurrentBackgroundUrl()})`,backgroundSize:'cover',backgroundPosition:'center'})},children:[gameState.appPhase==='homescreen'&&/*#__PURE__*/_jsx(NewHomeScreen,{onCreateRoom:createRoom,onJoinRoom:joinRoom}),gameState.appPhase==='readyscreen'&&/*#__PURE__*/_jsx(ReadyScreen,{gameState:gameState,socketId:socket?socket.id:null,onReady:setReady,onLeaveRoom:leaveRoom,onStartGame:startGame}),gameState.appPhase==='playing'&&/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(BoardStage,{board:gameState.board,players:gameState.players,socketId:socket?socket.id:null}),/*#__PURE__*/_jsx(ScorePanel,{score:currentScore,lastScoreChange:lastScoreChange,level:level,time:elapsedTime})]}),gameState.appPhase==='gameover'&&/*#__PURE__*/_jsx(GameOverScreen,{gameOverData:gameOverData,onPlayAgain:()=>{setIsGameOver(false);leaveRoom();}})]});}export default App;","map":{"version":3,"names":["React","useEffect","useState","useCallback","useRef","io","connectToCluster","BoardStage","NewHomeScreen","ReadyScreen","GameOverScreen","ScorePanel","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","BACKGROUND_IMAGES","BACKGROUND_CHANGE_INTERVAL","loadConfig","response","fetch","ok","Error","status","json","error","console","warn","serverAddress","DEBUG","events","state","render","debugLog","type","_len","arguments","length","args","Array","_key","log","getBackgroundUrl","index","process","env","PUBLIC_URL","App","socket","setSocket","gameState","setGameState","isGameOver","setIsGameOver","gameOverData","setGameOverData","isConnecting","setIsConnecting","setError","socketError","setSocketError","hardDropActiveRef","currentBackgroundIndex","setCurrentBackgroundIndex","backgroundIntervalRef","elapsedTime","setElapsedTime","currentScore","setCurrentScore","lastScoreChange","setLastScoreChange","level","setLevel","timerIntervalRef","reconnectTimeoutRef","reconnectionAttemptsRef","MAX_RECONNECT_ATTEMPTS","lastGameStateRef","getCurrentBackgroundUrl","connectToServer","currentUrl","window","location","origin","newSocket","clusterError","_config$client","config","client","on","id","current","err","message","info","isLeader","leaderAddress","disconnect","leaderSocket","newGameState","appPhase","player","players","newScore","score","Date","now","reason","initialState","roomCode","activePlayers","readyPlayers","prevState","_ref","_ref2","_ref3","playerId","_ref4","_ref5","data","clearTimeout","delay","Math","min","pow","setTimeout","clearInterval","setInterval","prevIndex","startTime","elapsed","floor","newLevel","max","handleKeyDown","e","includes","code","preventDefault","repeat","emit","direction","handleKeyUp","addEventListener","removeEventListener","_ref6","_ref7","off","createRoom","playerName","joinRoom","leaveRoom","setReady","isReady","startGame","className","children","onClick","reload","style","padding","backgroundColor","border","borderRadius","color","cursor","marginTop","backgroundImage","backgroundSize","backgroundPosition","onCreateRoom","onJoinRoom","socketId","onReady","onLeaveRoom","onStartGame","board","time","onPlayAgain"],"sources":["/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/App.js"],"sourcesContent":["import React, { useEffect, useState, useCallback, useRef } from 'react';\nimport { io } from 'socket.io-client';\nimport { connectToCluster } from './serverDiscovery';\nimport BoardStage from './BoardStage';\nimport NewHomeScreen from './NewHomeScreen';\nimport ReadyScreen from './ReadyScreen';\nimport GameOverScreen from './GameOverScreen';\nimport ScorePanel from './ScorePanel';\nimport './App.css';\n\n// Background image configuration\nconst BACKGROUND_IMAGES = [\n  'deep-tetris-color.jpg',\n  'tetris-1920-x-1080-background-hyihqau5t3lalo4e.png',\n  'tetris-2560-x-1600-background-3bjbi7nyulqbller.jpg',\n];\nconst BACKGROUND_CHANGE_INTERVAL = 30000; // 30 seconds\n\n// Load config file to get server address\nconst loadConfig = async () => {\n  try {\n    const response = await fetch('/config.json');\n    if (!response.ok) {\n      throw new Error(`Failed to load config: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.warn('Error loading config, using default server address:', error);\n    return { serverAddress: 'http://localhost:3001' };\n  }\n};\n\n// Debug logging\nconst DEBUG = {\n  events: true,\n  state: true,\n  render: false\n};\n\nfunction debugLog(type, ...args) {\n  if (DEBUG[type]) {\n    console.log(`[DEBUG:${type}]`, ...args);\n  }\n}\n\n// Function to get current background URL\nconst getBackgroundUrl = (index) => {\n  return `${process.env.PUBLIC_URL}/backgrounds/${BACKGROUND_IMAGES[index]}`;\n};\n\n// App component\nfunction App() {\n  const [socket, setSocket] = useState(null);\n  const [gameState, setGameState] = useState(null);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [gameOverData, setGameOverData] = useState(null);\n  const [isConnecting, setIsConnecting] = useState(true);\n  const [error, setError] = useState(null);\n  const [socketError, setSocketError] = useState(null);\n\n  // Hard‐drop guard so holding space won't repeat\n  const hardDropActiveRef = useRef(false);\n\n  // Add state for background rotation\n  const [currentBackgroundIndex, setCurrentBackgroundIndex] = useState(0);\n  const backgroundIntervalRef = useRef(null);\n\n  // Add state for timer and scoring\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const [currentScore, setCurrentScore] = useState(0);\n  const [lastScoreChange, setLastScoreChange] = useState(0);\n  const [level, setLevel] = useState(1);\n  const timerIntervalRef = useRef(null);\n\n  // For reconnection logic\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectionAttemptsRef = useRef(0);\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const lastGameStateRef = useRef(null);\n\n  // Function to get current background URL\n  const getCurrentBackgroundUrl = () => {\n    return getBackgroundUrl(currentBackgroundIndex);\n  };\n\n  // Connect to socket on component mount\n  useEffect(() => {\n    const connectToServer = async () => {\n      try {\n        setIsConnecting(true);\n        setSocketError(null);\n\n        const currentUrl = window.location.origin;\n\n        // Try to connect to the cluster\n        let newSocket;\n        try {\n          debugLog('events', 'Attempting to connect to server cluster');\n          newSocket = await connectToCluster(currentUrl);\n        } catch (clusterError) {\n          debugLog('events', 'Cluster connection failed, falling back to direct connection', clusterError);\n          \n          // Fall back to direct connection\n          const config = await loadConfig();\n          const serverAddress = config.client?.serverAddress || config.serverAddress || 'http://localhost:3001';\n          \n          debugLog('events', 'Connecting to server:', serverAddress);\n          newSocket = io(serverAddress);\n        }\n        \n        setSocket(newSocket);\n\n        // Socket event handlers\n        newSocket.on('connect', () => {\n          debugLog('events', 'Socket connected with ID:', newSocket.id);\n          setIsConnecting(false);\n          setSocketError(null);\n          reconnectionAttemptsRef.current = 0;\n        });\n\n        newSocket.on('connect_error', (err) => {\n          debugLog('events', 'Connection error:', err.message);\n          setSocketError(`Connection error: ${err.message}`);\n          setIsConnecting(false);\n        });\n\n        // Handle leader information updates\n        newSocket.on('leaderInfo', (info) => {\n          debugLog('events', 'Leader info received:', info);\n          \n          if (!info.isLeader && info.leaderAddress) {\n            debugLog('events', 'Redirecting to leader at:', info.leaderAddress);\n            \n            // Disconnect from current socket\n            newSocket.disconnect();\n            \n            // Connect to the leader\n            const leaderSocket = io(info.leaderAddress);\n            \n            // Set up all event handlers on the new socket\n            leaderSocket.on('connect', () => {\n              debugLog('events', 'Connected to leader with ID:', leaderSocket.id);\n              setIsConnecting(false);\n              setSocketError(null);\n              reconnectionAttemptsRef.current = 0;\n            });\n        \n            leaderSocket.on('gameState', (newGameState) => {\n              debugLog('state', 'Received gameState from leader:', newGameState);\n              setGameState(newGameState);\n              \n              // Update score if available\n              if (newGameState && newGameState.appPhase === 'playing') {\n                const player = newGameState.players[leaderSocket.id];\n                if (player) {\n                  const newScore = player.score || 0;\n                  if (newScore !== currentScore) {\n                    setLastScoreChange(Date.now());\n                    setCurrentScore(newScore);\n                  }\n                }\n              }\n            });\n        \n            leaderSocket.on('disconnect', (reason) => {\n              debugLog('events', 'Disconnected from leader:', reason);\n              // Add reconnection logic here if needed\n            });\n        \n            // Add other necessary event handlers\n            leaderSocket.on('init', (initialState) => {\n              debugLog('events', 'Received init from leader:', initialState);\n            });\n            \n            leaderSocket.on('error', (err) => {\n              debugLog('events', 'Leader socket error:', err);\n              setError(err.message);\n            });\n        \n            // Set the socket state to the new leader socket\n            setSocket(leaderSocket);\n          }\n        });\n\n        // Handle initial state\n        newSocket.on('init', (initialState) => {\n          debugLog('events', 'Received init event with state:', initialState);\n          // Apply initial state as gameState so UI can render homescreen\n          setGameState({\n            appPhase: initialState.appPhase,\n            players: {},\n            roomCode: null,\n            activePlayers: [],\n            readyPlayers: []\n          });\n        });\n\n        // Handle game state updates\n        newSocket.on('gameState', (newGameState) => {\n          debugLog('state', 'Received gameState update:', newGameState);\n          \n          setGameState((prevState) => {\n            // Store the game state for potential reconnection\n            if (newGameState) {\n              lastGameStateRef.current = newGameState;\n            }\n            \n            // Special case to prevent accidentally going back to homescreen\n            if (prevState?.appPhase === 'readyscreen' && newGameState?.appPhase === 'homescreen') {\n              debugLog('state', 'Ignoring homescreen gameState while in readyscreen');\n              return prevState;\n            }\n            \n            return newGameState;\n          });\n          \n          // Update score if available\n          if (newGameState && newGameState.appPhase === 'playing') {\n            // Find the player that corresponds to this client\n            const player = newGameState.players[newSocket.id];\n            if (player) {\n              const newScore = player.score || 0;\n              if (newScore !== currentScore) {\n                setLastScoreChange(Date.now());\n                setCurrentScore(newScore);\n              }\n            }\n          }\n        });\n\n        // Handle room creation\n        newSocket.on('roomCreated', ({ roomCode, gameState }) => {\n          debugLog('events', `Room created: ${roomCode}`);\n          setGameState(gameState);\n        });\n\n        // Handle joining a room\n        newSocket.on('roomJoined', ({ roomCode, gameState }) => {\n          debugLog('events', `Joined room: ${roomCode}`);\n          setGameState(gameState);\n        });\n\n        // Handle player joining\n        newSocket.on('playerJoined', ({ playerId, gameState }) => {\n          debugLog('events', `Player joined: ${playerId}`);\n          setGameState(gameState);\n        });\n\n        // Handle player leaving\n        newSocket.on('playerLeft', ({ playerId, gameState }) => {\n          debugLog('events', `Player left: ${playerId}`);\n          setGameState(gameState);\n        });\n        \n        // Handle host assignment (when previous host leaves)\n        newSocket.on('hostAssigned', ({ gameState }) => {\n          debugLog('events', 'You are now the host');\n          setGameState(gameState);\n        });\n\n        // Handle game over\n        newSocket.on('gameOver', (data) => {\n          debugLog('events', 'Game over:', data);\n          setIsGameOver(true);\n          setGameOverData(data);\n        });\n\n        // Handle server errors\n        newSocket.on('error', (err) => {\n          debugLog('events', 'Server error:', err);\n          setError(err.message);\n        });\n\n        // Handle disconnection with reconnection logic\n        newSocket.on('disconnect', (reason) => {\n          debugLog('events', 'Socket disconnected:', reason);\n          \n          // If the disconnect was not initiated by the client, attempt to reconnect\n          if (reason === 'io server disconnect' || reason === 'transport close' || reason === 'transport error') {\n            if (reconnectionAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\n              debugLog('events', `Attempting to reconnect (${reconnectionAttemptsRef.current + 1}/${MAX_RECONNECT_ATTEMPTS})...`);\n              setIsConnecting(true);\n              \n              // Clear any existing reconnection timeout\n              if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n              }\n              \n              // Exponential backoff for reconnection\n              const delay = Math.min(1000 * Math.pow(2, reconnectionAttemptsRef.current), 10000);\n              reconnectTimeoutRef.current = setTimeout(async () => {\n                reconnectionAttemptsRef.current++;\n                connectToServer();\n              }, delay);\n            } else {\n              debugLog('events', 'Max reconnection attempts reached');\n              setSocketError('Could not reconnect to the server. Please refresh the page.');\n              setIsConnecting(false);\n            }\n          }\n        });\n\n        // Return cleanup function\n        return () => {\n          debugLog('events', 'Cleaning up socket connection');\n          \n          if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n          }\n          \n          newSocket.disconnect();\n        };\n      } catch (err) {\n        console.error('Error connecting to server:', err);\n        setSocketError(`Error connecting to server: ${err.message}`);\n        setIsConnecting(false);\n      }\n    };\n\n    connectToServer();\n  }, []);\n\n  // Background rotation effect - only active during gameplay\n  useEffect(() => {\n    // Clear any existing background rotation interval\n    if (backgroundIntervalRef.current) {\n      clearInterval(backgroundIntervalRef.current);\n      backgroundIntervalRef.current = null;\n    }\n\n    // Start background rotation when game is playing\n    if (gameState && gameState.appPhase === 'playing') {\n      backgroundIntervalRef.current = setInterval(() => {\n        setCurrentBackgroundIndex((prevIndex) => \n          (prevIndex + 1) % BACKGROUND_IMAGES.length\n        );\n      }, BACKGROUND_CHANGE_INTERVAL);\n    }\n\n    return () => {\n      if (backgroundIntervalRef.current) {\n        clearInterval(backgroundIntervalRef.current);\n      }\n    };\n  }, [gameState?.appPhase]);\n\n  // Timer effect for gameplay\n  useEffect(() => {\n    if (gameState && gameState.appPhase === 'playing') {\n      if (!timerIntervalRef.current) {\n        const startTime = Date.now();\n        timerIntervalRef.current = setInterval(() => {\n          const elapsed = Math.floor((Date.now() - startTime) / 1000);\n          setElapsedTime(elapsed);\n          \n          // Update level based on time (every 30 seconds)\n          const newLevel = Math.max(1, Math.floor(elapsed / 30) + 1);\n          if (newLevel !== level) {\n            setLevel(newLevel);\n          }\n        }, 1000);\n      }\n    } else {\n      // Clear timer when not playing\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n        timerIntervalRef.current = null;\n      }\n      \n      // Reset timer and level when game ends\n      if (gameState && gameState.appPhase !== 'playing') {\n        setElapsedTime(0);\n        setLevel(1);\n      }\n    }\n    \n    return () => {\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n      }\n    };\n  }, [gameState?.appPhase, level]);\n\n  // Handle keydown events for gameplay\n  const handleKeyDown = useCallback((e) => {\n    if (!socket || !gameState || gameState.appPhase !== 'playing') return;\n\n    // Prevent default behavior for game controls\n    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space', 'KeyZ'].includes(e.code)) {\n      e.preventDefault();\n    }\n\n    // Only handle keys that aren't being repeated (except down)\n    if (!e.repeat || e.code === 'ArrowDown') {\n      switch (e.code) {\n        case 'ArrowLeft':\n          // First send immediate move, then start DAS\n          socket.emit('playerAction', { type: 'moveLeft' });\n          socket.emit('playerAction', { type: 'startDAS', direction: 'left' });\n          break;\n        case 'ArrowRight':\n          // First send immediate move, then start DAS\n          socket.emit('playerAction', { type: 'moveRight' });\n          socket.emit('playerAction', { type: 'startDAS', direction: 'right' });\n          break;\n        case 'ArrowUp':\n        case 'KeyZ':\n          socket.emit('playerAction', { type: 'rotate' });\n          break;\n        case 'ArrowDown':\n          socket.emit('playerAction', { type: 'softDrop' });\n          break;\n        case 'Space':\n          // guard against auto‑repeat when holding space\n          if (!hardDropActiveRef.current) {\n            socket.emit('playerAction', { type: 'hardDrop' });\n            hardDropActiveRef.current = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }, [socket, gameState]);\n\n  // Handle keyup events to stop DAS (delayed auto-shift)\n  const handleKeyUp = useCallback((e) => {\n    if (!socket || !gameState || gameState.appPhase !== 'playing') return;\n    \n    switch (e.code) {\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        socket.emit('playerAction', { type: 'stopDAS' });\n        break;\n      case 'Space':\n        hardDropActiveRef.current = false;\n        break;\n      default:\n        break;\n    }\n  }, [socket, gameState]);\n\n  // Add key event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    \n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handleKeyDown, handleKeyUp]);\n\n  // Ensure room events are handled on each socket reconnect\n  useEffect(() => {\n    if (!socket) return;\n\n    socket.on('roomCreated', ({ roomCode, gameState }) => {\n      debugLog('events', `Room created: ${roomCode}`);\n      setGameState(gameState);\n    });\n\n    socket.on('roomJoined', ({ roomCode, gameState }) => {\n      debugLog('events', `Joined room: ${roomCode}`);\n      setGameState(gameState);\n    });\n\n    return () => {\n      socket.off('roomCreated');\n      socket.off('roomJoined');\n    };\n  }, [socket]);\n\n  // Create a room\n  const createRoom = useCallback((playerName) => {\n    if (socket) {\n      debugLog('events', 'Creating room with player name:', playerName);\n      socket.emit('createRoom', playerName);\n    }\n  }, [socket]);\n\n  // Join a room\n  const joinRoom = useCallback((roomCode, playerName) => {\n    if (socket) {\n      debugLog('events', `Joining room ${roomCode} with player name: ${playerName}`);\n      socket.emit('joinRoom', { roomCode, playerName });\n    }\n  }, [socket]);\n\n  // Leave a room\n  const leaveRoom = useCallback(() => {\n    if (socket) {\n      debugLog('events', 'Leaving room');\n      socket.emit('leaveRoom');\n    }\n  }, [socket]);\n\n  // Set player ready state\n  const setReady = useCallback((isReady) => {\n    if (socket) {\n      debugLog('events', `Setting ready state: ${isReady}`);\n      socket.emit('playerReady', isReady);\n    }\n  }, [socket]);\n\n  // Start the game (host only)\n  const startGame = useCallback(() => {\n    if (socket) {\n      debugLog('events', 'Starting game');\n      socket.emit('startGame');\n    }\n  }, [socket]);\n\n  // Show error message if there's a socket error\n  if (socketError) {\n    return (\n      <div className=\"App error-screen\">\n        <h1>Connection Error</h1>\n        <p>{socketError}</p>\n        <p>Please check that the server is running and the configuration is correct.</p>\n        <button\n          onClick={() => window.location.reload()}\n          style={{\n            padding: '10px 20px',\n            backgroundColor: '#FF5733',\n            border: 'none',\n            borderRadius: '4px',\n            color: 'white',\n            cursor: 'pointer',\n            marginTop: '20px'\n          }}\n        >\n          Retry Connection\n        </button>\n      </div>\n    );\n  }\n\n  // Show loading screen if no game state\n  if (!gameState) {\n    return <div className=\"App\"><h1>Waiting for game state...</h1></div>;\n  }\n\n  // Render appropriate screen based on app phase\n  return (\n    <div\n      className=\"App\"\n      style={{\n        ...(gameState.appPhase === 'playing' && {\n          backgroundImage: `url(${getCurrentBackgroundUrl()})`,\n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n        }),\n      }}\n    >\n      {gameState.appPhase === 'homescreen' && (\n        <NewHomeScreen\n          onCreateRoom={createRoom}\n          onJoinRoom={joinRoom}\n        />\n      )}\n      \n      {gameState.appPhase === 'readyscreen' && (\n        <ReadyScreen\n          gameState={gameState}\n          socketId={socket ? socket.id : null}\n          onReady={setReady}\n          onLeaveRoom={leaveRoom}\n          onStartGame={startGame}\n        />\n      )}\n      \n      {gameState.appPhase === 'playing' && (\n        <>\n          <BoardStage\n            board={gameState.board}\n            players={gameState.players}\n            socketId={socket ? socket.id : null}\n          />\n          <ScorePanel\n            score={currentScore}\n            lastScoreChange={lastScoreChange}\n            level={level}\n            time={elapsedTime}\n          />\n        </>\n      )}\n      \n      {gameState.appPhase === 'gameover' && (\n        <GameOverScreen\n          gameOverData={gameOverData}\n          onPlayAgain={() => {\n            setIsGameOver(false);\n            leaveRoom();\n          }}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}