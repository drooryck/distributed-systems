{"ast":null,"code":"import{io}from'socket.io-client';import{EventEmitter}from'events';import{saveGameSession,getGameSession,clearGameSession}from'./sessionStorage';// Add this function to load the config at the top of your file\nasync function loadConfig(){try{// Get the current hostname - this lets it work from any address\nconst currentUrl=new URL(window.location.href);const configPath=`${currentUrl.protocol}//${currentUrl.host}/config.json`;console.log(`Loading config from ${configPath}`);const response=await fetch(configPath);if(!response.ok){console.warn(`Failed to load config.json: ${response.status}`);return null;}const config=await response.json();console.log('Successfully loaded config:',config);return config;}catch(error){console.warn('Error loading config.json:',error);return null;}}class ServerConnectionManager extends EventEmitter{constructor(){super();this.serverList=[];this.activeSocket=null;this.socketId=null;// Configuration\nthis.debug=true;this.autoReconnect=true;this.reconnectInterval=2000;// Status tracking\nthis.initialized=false;this.reconnectTimer=null;}log(message){if(this.debug){console.log(`[ServerManager] ${message}`);}}async initialize(){let onConnectedCallback=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let onStateChangeCallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let serverList=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(this.initialized){return;}this.onConnectedCallback=onConnectedCallback;this.onStateChangeCallback=onStateChangeCallback;// Try to load server list from config.json first\nlet configServers=null;try{const config=await loadConfig();if(config&&config.client&&Array.isArray(config.client.serverAddresses)){configServers=config.client.serverAddresses;this.log(`Loaded ${configServers.length} servers from config.json`);// log the whole addresses\n// configServers.forEach((server, index) => {\n//   this.log(`Server ${index}: ${JSON.stringify(server)}`);\n// });\n}}catch(e){this.log(`Error loading config: ${e.message}`);}try{// Use provided server list or default to localhost ports\nthis.serverList=configServers||[{id:0,host:'localhost',port:3001},{id:1,host:'localhost',port:3002},{id:2,host:'localhost',port:3003}];this.log(`Initializing connection manager with ${this.serverList.length} servers`);// log the whole server list\nthis.serverList.forEach((server,index)=>{this.log(`Server ${index}: ${JSON.stringify(server)}`);});// First try to connect to any server to find the leader\nlet leaderServer=null;for(const server of this.serverList){const serverUrl=`http://${server.host}:${server.port}`;try{this.log(`Checking server ${serverUrl} for leader info`);const socket=io(serverUrl,{reconnection:false,timeout:5000});// Wait for connection or timeout\nconst isConnected=await new Promise(resolve=>{const timeout=setTimeout(()=>{socket.disconnect();resolve(false);},5000);socket.on('connect',()=>{clearTimeout(timeout);resolve(true);});socket.on('connect_error',()=>{clearTimeout(timeout);socket.disconnect();resolve(false);});});if(isConnected){// Get leader info from this server\nconst leaderInfo=await new Promise(resolve=>{socket.emit('checkLeader',{},response=>{if(response&&response.isLeader){// This server is the leader\nresolve({id:server.id,host:server.host,port:server.port,url:serverUrl});}else if(response&&response.leaderUrl){// Get leader info from response\nconst leaderParts=response.leaderUrl.split(':');const leaderPort=parseInt(leaderParts[leaderParts.length-1]);const leaderHost=leaderParts[leaderParts.length-2].replace(/\\/\\//g,'');resolve({id:response.leaderId||0,host:leaderHost,port:leaderPort,url:response.leaderUrl});}else{// No leader info, use this server temporarily\nresolve({id:server.id,host:server.host,port:server.port,url:serverUrl});}});// If no response in 3 seconds, just use this server\nsetTimeout(()=>{resolve({id:server.id,host:server.host,port:server.port,url:serverUrl});},3000);});socket.disconnect();leaderServer=leaderInfo;break;}}catch(error){this.log(`Error checking server ${serverUrl}: ${error.message}`);// Continue to next server\n}}// Now connect to the leader server or first server if no leader found\nif(leaderServer){this.log(`Connecting to leader server at ${leaderServer.url}`);await this.connectToServer(leaderServer);}else if(this.serverList.length>0){// Try each server until one works\nfor(const server of this.serverList){const serverUrl=`http://${server.host}:${server.port}`;try{this.log(`Trying to connect to server ${serverUrl}`);await this.connectToServer({id:server.id,host:server.host,port:server.port,url:serverUrl});if(this.activeSocket)break;}catch(error){this.log(`Failed to connect to ${serverUrl}: ${error.message}`);}}}this.initialized=true;// If we don't have a connection yet, schedule a retry\nif(!this.activeSocket&&this.autoReconnect){this.scheduleReconnect();}}catch(error){this.log(`Initialization error: ${error.message}`);if(this.autoReconnect){this.scheduleReconnect();}}}async connectToServer(server){if(!server||!server.url){throw new Error('Invalid server configuration');}const serverUrl=new URL(server.url);const absoluteUrl=`http://${serverUrl.hostname}:${serverUrl.port}`;this.log(`Connecting to server at ${absoluteUrl}`);// Connect using the absolute URL (not relative)\nconst socket=io(absoluteUrl,{reconnection:true,reconnectionAttempts:5,reconnectionDelay:1000,reconnectionDelayMax:5000,timeout:10000,transports:['polling','websocket']// Try polling first, then websocket\n});return new Promise((resolve,reject)=>{// Set up connection timeout\nconst timeout=setTimeout(()=>{socket.disconnect();reject(new Error(`Connection timeout to ${server.url}`));},10000);// Handle connection\nsocket.on('connect',()=>{clearTimeout(timeout);this.log(`Connected to server at ${server.url}`);this.setActiveServer(socket,server);resolve(true);});// Handle connection error\nsocket.on('connect_error',error=>{clearTimeout(timeout);this.log(`Connection error to ${server.url}: ${error.message}`);reject(error);});// Handle disconnection\nsocket.on('disconnect',reason=>{this.log(`Disconnected from ${server.url}: ${reason}`);// If this was our active socket, try to reconnect\nif(this.activeSocket===socket){this.activeSocket=null;// Notify about server change\nif(this.onStateChangeCallback){this.onStateChangeCallback({type:'disconnected',message:`Disconnected from server: ${reason}`});}if(this.autoReconnect&&reason!=='io client disconnect'){this.scheduleReconnect();}}});});}setActiveServer(socket,server){this.activeSocket=socket;this.socketId=socket.id;// Forward events from this socket\nthis.forwardEvents(socket);if(needsRejoin==='true'){this.log(`Detected post-redirect rejoin flag, waiting for stable connection`);// Add a 500ms delay for connection stability before attempting rejoin\nsetTimeout(()=>{this.log(`Attempting delayed room rejoin after redirection`);localStorage.removeItem('needs_browser_rejoin');this.attemptRoomRejoin(socket);},500);}else{// Normal room rejoin attempt for regular connections\nthis.attemptRoomRejoin(socket);}// Call the connected callback if provided\nif(this.onConnectedCallback){this.onConnectedCallback(socket);}// Notify about server change\nif(this.onStateChangeCallback){this.onStateChangeCallback({type:'connected',server:server.url});}}scheduleReconnect(){// First check if our origin server is different from active leader\nconst currentUrl=new URL(window.location.href);const currentPort=currentUrl.port;// Try to find a working server to redirect to\nthis.serverList.forEach(server=>{if(server.port.toString()!==currentPort){// Try a basic ping to see if this server is alive\nfetch(`http://${server.host}:${server.port}/status`,{timeout:2000}).then(response=>{if(response.ok){// Found a working server, redirect the browser\nthis.log(`Redirecting to working server: ${server.port}`);// EXPLICITLY save session data before redirect\nif(session&&session.roomCode){this.log(`Saving session for ${session.roomCode} before redirect`);saveGameSession(session);localStorage.setItem('needs_browser_rejoin','true');}// Redirect the browser to the new server\nwindow.location.href=window.location.href.replace(`:${currentPort}`,`:${server.port}`);return;}}).catch(()=>{// This server is also down, try the next one\n});}});// Continue with normal reconnection if we didn't redirect\nif(this.reconnectTimer){clearTimeout(this.reconnectTimer);}this.reconnectTimer=setTimeout(async()=>{this.log('Attempting to reconnect...');await this.initialize(this.onConnectedCallback,this.onStateChangeCallback);},this.reconnectInterval);}forwardEvents(socket){if(!socket)return;socket.on('error',data=>{if(data.message&&data.message.includes('Room not found')){this.log(`Room rejoin failed: ${data.message}`);// If we were trying to rejoin but the room doesn't exist anymore\nconst needsRejoin=localStorage.getItem('needs_browser_rejoin');if(needsRejoin==='true'){localStorage.removeItem('needs_browser_rejoin');this.log(`Clearing failed rejoin flag`);}}this.emit('error',data);});// Forward common events from the socket to this event emitter\nconst eventsToForward=['init','gameState','roomCreated','roomJoined','roomRejoined','roomLeft','playerJoined','playerLeft','playerReady','gameStarted','gameOver','error','disconnect'];eventsToForward.forEach(eventName=>{socket.on(eventName,data=>{if(eventName==='init'&&typeof data==='string'){try{const parsedData=JSON.parse(data);this.log(`Converted string to object for init event`);data=parsedData;}catch(e){this.log(`Could not parse init string as JSON, creating default homescreen state`);data={appPhase:'homescreen',socketId:socket.id,players:{},activePlayers:[],readyPlayers:[],gameInProgress:false};}}this.emit(eventName,data);});});}attemptRoomRejoin(socket){const session=getGameSession();if(session&&session.roomCode){this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);// Check if player was ready before disconnection\n// This is determined by looking at the readyPlayers array in localStorage if available\nlet wasReady=false;try{// Try to determine if player was ready by checking local storage\nconst localReadyStatus=localStorage.getItem(`player_ready_${session.socketId}`);if(localReadyStatus==='true'){wasReady=true;this.log(`Player was previously ready, sending ready status in rejoin`);}}catch(e){this.log(`Could not determine previous ready status: ${e.message}`);}socket.emit('rejoinRoom',{roomCode:session.roomCode,playerName:session.playerName,previousSocketId:session.socketId||this.socketId,wasReady:wasReady// Include ready status in rejoin request\n});}}emit(eventName,data){// For non-EventEmitter events, send to server\nif(eventName!=='newListener'&&eventName!=='removeListener'){if(this.activeSocket){this.activeSocket.emit(eventName,data);}else{this.log(`Cannot emit ${eventName}: no active socket`);}}// Always forward all events to local listeners\nreturn super.emit(eventName,data);}getSocket(){return this.activeSocket;}getSocketId(){return this.socketId;}disconnect(){if(this.activeSocket){this.activeSocket.disconnect();}this.activeSocket=null;this.initialized=false;if(this.reconnectTimer){clearTimeout(this.reconnectTimer);this.reconnectTimer=null;}}}// Create a singleton instance\nconst serverManager=new ServerConnectionManager();export default serverManager;","map":{"version":3,"names":["io","EventEmitter","saveGameSession","getGameSession","clearGameSession","loadConfig","currentUrl","URL","window","location","href","configPath","protocol","host","console","log","response","fetch","ok","warn","status","config","json","error","ServerConnectionManager","constructor","serverList","activeSocket","socketId","debug","autoReconnect","reconnectInterval","initialized","reconnectTimer","message","initialize","onConnectedCallback","arguments","length","undefined","onStateChangeCallback","configServers","client","Array","isArray","serverAddresses","e","id","port","forEach","server","index","JSON","stringify","leaderServer","serverUrl","socket","reconnection","timeout","isConnected","Promise","resolve","setTimeout","disconnect","on","clearTimeout","leaderInfo","emit","isLeader","url","leaderUrl","leaderParts","split","leaderPort","parseInt","leaderHost","replace","leaderId","connectToServer","scheduleReconnect","Error","absoluteUrl","hostname","reconnectionAttempts","reconnectionDelay","reconnectionDelayMax","transports","reject","setActiveServer","reason","type","forwardEvents","needsRejoin","localStorage","removeItem","attemptRoomRejoin","currentPort","toString","then","session","roomCode","setItem","catch","data","includes","getItem","eventsToForward","eventName","parsedData","parse","appPhase","players","activePlayers","readyPlayers","gameInProgress","playerName","wasReady","localReadyStatus","previousSocketId","getSocket","getSocketId","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\n// Add this function to load the config at the top of your file\nasync function loadConfig() {\n  try {\n    // Get the current hostname - this lets it work from any address\n    const currentUrl = new URL(window.location.href);\n    const configPath = `${currentUrl.protocol}//${currentUrl.host}/config.json`;\n    \n    console.log(`Loading config from ${configPath}`);\n    const response = await fetch(configPath);\n    \n    if (!response.ok) {\n      console.warn(`Failed to load config.json: ${response.status}`);\n      return null;\n    }\n    \n    const config = await response.json();\n    console.log('Successfully loaded config:', config);\n    return config;\n  } catch (error) {\n    console.warn('Error loading config.json:', error);\n    return null;\n  }\n}\n\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.serverList = [];\n    this.activeSocket = null;\n    this.socketId = null;\n    \n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n    \n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  \n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  \n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    \n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n\n\n    // Try to load server list from config.json first\n    let configServers = null;\n    try {\n      const config = await loadConfig();\n      if (config && config.client && Array.isArray(config.client.serverAddresses)) {\n        configServers = config.client.serverAddresses;\n\n        this.log(`Loaded ${configServers.length} servers from config.json`);\n        // log the whole addresses\n\n        // configServers.forEach((server, index) => {\n        //   this.log(`Server ${index}: ${JSON.stringify(server)}`);\n        // });\n\n      }\n    } catch (e) {\n      this.log(`Error loading config: ${e.message}`);\n    }\n  \n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = configServers || [\n        { id: 0, host: 'localhost', port: 3001 },\n        { id: 1, host: 'localhost', port: 3002 }, \n        { id: 2, host: 'localhost', port: 3003 }\n      ];\n      \n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n      // log the whole server list\n      this.serverList.forEach((server, index) => {\n        this.log(`Server ${index}: ${JSON.stringify(server)}`);\n      });\n      \n      // First try to connect to any server to find the leader\n      let leaderServer = null;\n      \n      for (const server of this.serverList) {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        try {\n          this.log(`Checking server ${serverUrl} for leader info`);\n          const socket = io(serverUrl, {\n            reconnection: false,\n            timeout: 5000\n          });\n          \n          // Wait for connection or timeout\n          const isConnected = await new Promise((resolve) => {\n            const timeout = setTimeout(() => {\n              socket.disconnect();\n              resolve(false);\n            }, 5000);\n            \n            socket.on('connect', () => {\n              clearTimeout(timeout);\n              resolve(true);\n            });\n            \n            socket.on('connect_error', () => {\n              clearTimeout(timeout);\n              socket.disconnect();\n              resolve(false);\n            });\n          });\n          \n          if (isConnected) {\n            // Get leader info from this server\n            const leaderInfo = await new Promise((resolve) => {\n              socket.emit('checkLeader', {}, (response) => {\n                if (response && response.isLeader) {\n                  // This server is the leader\n                  resolve({\n                    id: server.id,\n                    host: server.host,\n                    port: server.port,\n                    url: serverUrl\n                  });\n                } else if (response && response.leaderUrl) {\n                  // Get leader info from response\n                  const leaderParts = response.leaderUrl.split(':');\n                  const leaderPort = parseInt(leaderParts[leaderParts.length - 1]);\n                  const leaderHost = leaderParts[leaderParts.length - 2].replace(/\\/\\//g, '');\n                  \n                  resolve({\n                    id: response.leaderId || 0,\n                    host: leaderHost,\n                    port: leaderPort,\n                    url: response.leaderUrl\n                  });\n                } else {\n                  // No leader info, use this server temporarily\n                  resolve({\n                    id: server.id,\n                    host: server.host,\n                    port: server.port,\n                    url: serverUrl\n                  });\n                }\n              });\n              \n              // If no response in 3 seconds, just use this server\n              setTimeout(() => {\n                resolve({\n                  id: server.id,\n                  host: server.host,\n                  port: server.port,\n                  url: serverUrl\n                });\n              }, 3000);\n            });\n            \n            socket.disconnect();\n            leaderServer = leaderInfo;\n            break;\n          }\n        } catch (error) {\n          this.log(`Error checking server ${serverUrl}: ${error.message}`);\n          // Continue to next server\n        }\n      }\n      \n      // Now connect to the leader server or first server if no leader found\n      if (leaderServer) {\n        this.log(`Connecting to leader server at ${leaderServer.url}`);\n        await this.connectToServer(leaderServer);\n      } else if (this.serverList.length > 0) {\n        // Try each server until one works\n        for (const server of this.serverList) {\n          const serverUrl = `http://${server.host}:${server.port}`;\n          try {\n            this.log(`Trying to connect to server ${serverUrl}`);\n            await this.connectToServer({ \n              id: server.id,\n              host: server.host,\n              port: server.port,\n              url: serverUrl\n            });\n            if (this.activeSocket) break;\n          } catch (error) {\n            this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n          }\n        }\n      }\n      \n      this.initialized = true;\n      \n      // If we don't have a connection yet, schedule a retry\n      if (!this.activeSocket && this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      if (this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    }\n  }\n  \n  async connectToServer(server) {\n    if (!server || !server.url) {\n      throw new Error('Invalid server configuration');\n    }\n    \n    const serverUrl = new URL(server.url);\n    const absoluteUrl = `http://${serverUrl.hostname}:${serverUrl.port}`;\n    \n    this.log(`Connecting to server at ${absoluteUrl}`);\n    \n    // Connect using the absolute URL (not relative)\n    const socket = io(absoluteUrl, {\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n      timeout: 10000,\n      transports: ['polling', 'websocket'] // Try polling first, then websocket\n    });\n    \n    return new Promise((resolve, reject) => {\n      \n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.disconnect();\n        reject(new Error(`Connection timeout to ${server.url}`));\n      }, 10000);\n      \n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server at ${server.url}`);\n        this.setActiveServer(socket, server);\n        resolve(true);\n      });\n      \n      // Handle connection error\n      socket.on('connect_error', (error) => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${server.url}: ${error.message}`);\n        reject(error);\n      });\n      \n      // Handle disconnection\n      socket.on('disconnect', (reason) => {\n        this.log(`Disconnected from ${server.url}: ${reason}`);\n        \n        // If this was our active socket, try to reconnect\n        if (this.activeSocket === socket) {\n          this.activeSocket = null;\n          \n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'disconnected',\n              message: `Disconnected from server: ${reason}`\n            });\n          }\n          \n          if (this.autoReconnect && reason !== 'io client disconnect') {\n            this.scheduleReconnect();\n          }\n        }\n      });\n    });\n  }\n  \n  setActiveServer(socket, server) {\n    this.activeSocket = socket;\n    this.socketId = socket.id;\n    \n    // Forward events from this socket\n    this.forwardEvents(socket);\n    \n    if (needsRejoin === 'true') {\n      this.log(`Detected post-redirect rejoin flag, waiting for stable connection`);\n      // Add a 500ms delay for connection stability before attempting rejoin\n      setTimeout(() => {\n        this.log(`Attempting delayed room rejoin after redirection`);\n        localStorage.removeItem('needs_browser_rejoin');\n        this.attemptRoomRejoin(socket);\n      }, 500);\n    } else {\n      // Normal room rejoin attempt for regular connections\n      this.attemptRoomRejoin(socket);\n    }\n    \n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(socket);\n    }\n    \n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'connected',\n        server: server.url,\n      });\n    }\n  }\n  \n  scheduleReconnect() {\n    // First check if our origin server is different from active leader\n    const currentUrl = new URL(window.location.href);\n    const currentPort = currentUrl.port;\n    \n    // Try to find a working server to redirect to\n    this.serverList.forEach(server => {\n      if (server.port.toString() !== currentPort) {\n        // Try a basic ping to see if this server is alive\n        fetch(`http://${server.host}:${server.port}/status`, { timeout: 2000 })\n          .then(response => {\n            if (response.ok) {\n              // Found a working server, redirect the browser\n              this.log(`Redirecting to working server: ${server.port}`);\n              \n              // EXPLICITLY save session data before redirect\n              if (session && session.roomCode) {\n                this.log(`Saving session for ${session.roomCode} before redirect`);\n                saveGameSession(session);\n                localStorage.setItem('needs_browser_rejoin', 'true');\n              }\n              \n              // Redirect the browser to the new server\n              window.location.href = window.location.href.replace(\n                `:${currentPort}`,\n                `:${server.port}`\n              );\n              return;\n            }\n          })\n          .catch(() => {\n            // This server is also down, try the next one\n          });\n      }\n    });\n    \n    // Continue with normal reconnection if we didn't redirect\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    \n    this.reconnectTimer = setTimeout(async () => {\n      this.log('Attempting to reconnect...');\n      await this.initialize(this.onConnectedCallback, this.onStateChangeCallback);\n    }, this.reconnectInterval);\n  }\n  \n  forwardEvents(socket) {\n    if (!socket) return;\n\n    socket.on('error', (data) => {\n      if (data.message && data.message.includes('Room not found')) {\n        this.log(`Room rejoin failed: ${data.message}`);\n        // If we were trying to rejoin but the room doesn't exist anymore\n        const needsRejoin = localStorage.getItem('needs_browser_rejoin');\n        if (needsRejoin === 'true') {\n          localStorage.removeItem('needs_browser_rejoin');\n          this.log(`Clearing failed rejoin flag`);\n        }\n      }\n      \n      this.emit('error', data);\n    });\n    \n    // Forward common events from the socket to this event emitter\n    const eventsToForward = [\n      'init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined',\n      'roomLeft', 'playerJoined', 'playerLeft', 'playerReady',\n      'gameStarted', 'gameOver', 'error', 'disconnect'\n    ];\n    \n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, (data) => {\n        if (eventName === 'init' && typeof data === 'string') {\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = { \n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        \n        this.emit(eventName, data);\n      });\n    });\n  }\n  \n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n      \n      // Check if player was ready before disconnection\n      // This is determined by looking at the readyPlayers array in localStorage if available\n      let wasReady = false;\n      try {\n        // Try to determine if player was ready by checking local storage\n        const localReadyStatus = localStorage.getItem(`player_ready_${session.socketId}`);\n        if (localReadyStatus === 'true') {\n          wasReady = true;\n          this.log(`Player was previously ready, sending ready status in rejoin`);\n        }\n      } catch (e) {\n        this.log(`Could not determine previous ready status: ${e.message}`);\n      }\n      \n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId || this.socketId,\n        wasReady: wasReady // Include ready status in rejoin request\n      });\n    }\n  }\n  \n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n    \n    // Always forward all events to local listeners\n    return super.emit(eventName, data);\n  }\n  \n  getSocket() {\n    return this.activeSocket;\n  }\n  \n  getSocketId() {\n    return this.socketId;\n  }\n  \n  disconnect() {\n    if (this.activeSocket) {\n      this.activeSocket.disconnect();\n    }\n    \n    this.activeSocket = null;\n    this.initialized = false;\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}