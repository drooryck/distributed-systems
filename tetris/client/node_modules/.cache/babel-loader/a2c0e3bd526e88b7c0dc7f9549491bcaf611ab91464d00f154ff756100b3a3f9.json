{"ast":null,"code":"import { io } from 'socket.io-client';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\nclass ServerConnectionManager {\n  constructor() {\n    this.servers = [];\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.eventHandlers = {};\n    this.debugMode = true;\n  }\n  log(message, data) {\n    if (this.debugMode) {\n      console.log(`[ServerManager] ${message}`, data !== undefined ? data : '');\n    }\n  }\n  async initialize(onConnected, onStateChange) {\n    try {\n      // Load server configuration\n      const response = await fetch('/config.json');\n      const config = await response.json();\n      if (!config.client || !config.client.serverAddresses || !config.client.serverAddresses.length) {\n        throw new Error(\"No server addresses configured\");\n      }\n      this.log(\"Initializing with server addresses:\", config.client.serverAddresses);\n\n      // Connect to all servers simultaneously\n      const connections = [];\n      for (const serverUrl of config.client.serverAddresses) {\n        this.log(`Connecting to ${serverUrl}...`);\n        const socket = io(serverUrl, {\n          reconnectionAttempts: 3,\n          reconnectionDelay: 1000,\n          timeout: 3000\n        });\n\n        // Create a connection object to track this server\n        const connection = {\n          url: serverUrl,\n          socket: socket,\n          isConnected: false,\n          isLeader: false,\n          serverId: null\n        };\n        connections.push(connection);\n\n        // Set up connection events\n        socket.on('connect', () => {\n          this.log(`Connected to ${serverUrl} with socket ID: ${socket.id}`);\n          connection.isConnected = true;\n\n          // Explicitly request initial state to fix \"waiting\" issue\n          socket.emit('requestInitialState');\n\n          // Ask if this is the leader server\n          socket.emit('checkLeader', {}, response => {\n            this.log(`Leader check response from ${serverUrl}:`, response);\n            if (response.isLeader) {\n              this.log(`Server ${serverUrl} is leader with ID: ${response.leaderId}`);\n\n              // Update connection info\n              connection.isLeader = true;\n              connection.serverId = response.leaderId;\n\n              // Set this as the active leader if we don't have one yet\n              if (!this.leaderServer) {\n                this.setActiveLeader(connection);\n\n                // Check for saved session and try to rejoin a room\n                this.attemptRoomRejoin(connection.socket);\n                if (onConnected) {\n                  onConnected(connection.socket);\n                }\n              }\n            } else {\n              this.log(`Server ${serverUrl} is NOT leader (leader is: ${response.leaderId})`);\n              connection.isLeader = false;\n              connection.serverId = response.leaderId;\n\n              // If we have no connections, use this as a fallback\n              if (!this.leaderServer && !this.activeSocket) {\n                this.setActiveLeader(connection);\n                if (onConnected) {\n                  onConnected(connection.socket);\n                }\n              }\n            }\n          });\n        });\n\n        // Handle server status changes (leader election changes)\n        socket.on('server-status', status => {\n          this.log(`Server status from ${serverUrl}:`, status);\n          connection.isLeader = status.isLeader;\n          connection.serverId = status.serverId;\n\n          // If this server just became leader, switch to it\n          if (status.isLeader && this.leaderServer !== connection) {\n            this.log(`Server ${serverUrl} became the new leader`);\n            this.setActiveLeader(connection);\n            if (onStateChange) {\n              onStateChange({\n                type: 'leaderChanged',\n                server: connection\n              });\n            }\n\n            // Try to rejoin existing room if we have session data\n            this.attemptRoomRejoin(connection.socket);\n          }\n        });\n\n        // Handle disconnect\n        socket.on('disconnect', () => {\n          this.log(`Disconnected from ${serverUrl}`);\n          connection.isConnected = false;\n\n          // If this was the leader, try to find another leader\n          if (this.leaderServer === connection) {\n            this.log('Leader server disconnected, looking for a new leader...');\n            this.leaderServer = null;\n            this.activeSocket = null;\n\n            // Find a new leader among connected servers\n            const newLeader = this.servers.find(s => s.isConnected && s.isLeader);\n            if (newLeader) {\n              this.log(`Found new leader: ${newLeader.url}`);\n              this.setActiveLeader(newLeader);\n              if (onStateChange) {\n                onStateChange({\n                  type: 'leaderChanged',\n                  server: newLeader\n                });\n              }\n\n              // Try to rejoin existing room\n              this.attemptRoomRejoin(newLeader.socket);\n            } else {\n              // Try any connected server if no leader is found\n              const anyServer = this.servers.find(s => s.isConnected);\n              if (anyServer) {\n                this.log(`No leader found, using connected server: ${anyServer.url}`);\n                this.setActiveLeader(anyServer);\n                if (onStateChange) {\n                  onStateChange({\n                    type: 'leaderChanged',\n                    server: anyServer\n                  });\n                }\n\n                // Try to rejoin existing room\n                this.attemptRoomRejoin(anyServer.socket);\n              } else {\n                this.log('No servers available. All servers are down.');\n                if (onStateChange) {\n                  onStateChange({\n                    type: 'allServersDown'\n                  });\n                }\n              }\n            }\n          }\n        });\n\n        // Setup instance-specific error handler\n        socket.on('connect_error', error => {\n          this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        });\n      }\n\n      // Store all server connections\n      this.servers = connections;\n      return true;\n    } catch (error) {\n      this.log('Error initializing server connections:', error);\n      throw error;\n    }\n  }\n  setActiveLeader(connection) {\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    this.log(`Active leader set to ${connection.url}`);\n\n    // Set up event forwarding\n    this.forwardEvents(connection.socket);\n\n    // Request initial state from new leader to fix \"waiting\" issue\n    connection.socket.emit('requestInitialState');\n  }\n  forwardEvents(socket) {\n    // Remove handlers from previous socket\n    for (const [event, handlers] of Object.entries(this.eventHandlers)) {\n      for (const handler of handlers) {\n        if (this.previousSocket) {\n          this.previousSocket.off(event, handler);\n        }\n      }\n    }\n\n    // Add handlers to new socket\n    for (const [event, handlers] of Object.entries(this.eventHandlers)) {\n      for (const handler of handlers) {\n        socket.on(event, handler);\n      }\n    }\n    this.previousSocket = socket;\n  }\n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (!session || !session.roomCode || this.hasRejoinedRoom) return false;\n    this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n    socket.emit('rejoinRoom', {\n      roomCode: session.roomCode,\n      playerName: session.playerName,\n      previousSocketId: session.socketId\n    });\n    return true;\n  }\n  on(event, callback) {\n    if (!this.eventHandlers[event]) {\n      this.eventHandlers[event] = [];\n    }\n    this.eventHandlers[event].push(callback);\n\n    // If we already have an active socket, register the handler immediately\n    if (this.activeSocket) {\n      this.activeSocket.on(event, callback);\n    }\n  }\n  emit(event, ...args) {\n    if (!this.activeSocket) {\n      this.log(`Warning: Tried to emit ${event} but no active socket`);\n      return false;\n    }\n    this.activeSocket.emit(event, ...args);\n    return true;\n  }\n  getActiveServer() {\n    return this.leaderServer;\n  }\n  getSocketId() {\n    return this.activeSocket ? this.activeSocket.id : null;\n  }\n  disconnect() {\n    for (const server of this.servers) {\n      if (server.socket) {\n        server.socket.disconnect();\n      }\n    }\n    this.servers = [];\n    this.leaderServer = null;\n    this.activeSocket = null;\n  }\n}\n\n// Create singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;","map":{"version":3,"names":["io","saveGameSession","getGameSession","clearGameSession","ServerConnectionManager","constructor","servers","leaderServer","activeSocket","eventHandlers","debugMode","log","message","data","console","undefined","initialize","onConnected","onStateChange","response","fetch","config","json","client","serverAddresses","length","Error","connections","serverUrl","socket","reconnectionAttempts","reconnectionDelay","timeout","connection","url","isConnected","isLeader","serverId","push","on","id","emit","leaderId","setActiveLeader","attemptRoomRejoin","status","type","server","newLeader","find","s","anyServer","error","forwardEvents","event","handlers","Object","entries","handler","previousSocket","off","session","roomCode","hasRejoinedRoom","playerName","previousSocketId","socketId","callback","args","getActiveServer","getSocketId","disconnect","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\nclass ServerConnectionManager {\n  constructor() {\n    this.servers = [];\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.eventHandlers = {};\n    this.debugMode = true;\n  }\n\n  log(message, data) {\n    if (this.debugMode) {\n      console.log(`[ServerManager] ${message}`, data !== undefined ? data : '');\n    }\n  }\n\n  async initialize(onConnected, onStateChange) {\n    try {\n      // Load server configuration\n      const response = await fetch('/config.json');\n      const config = await response.json();\n      \n      if (!config.client || !config.client.serverAddresses || !config.client.serverAddresses.length) {\n        throw new Error(\"No server addresses configured\");\n      }\n      \n      this.log(\"Initializing with server addresses:\", config.client.serverAddresses);\n      \n      // Connect to all servers simultaneously\n      const connections = [];\n      \n      for (const serverUrl of config.client.serverAddresses) {\n        this.log(`Connecting to ${serverUrl}...`);\n        \n        const socket = io(serverUrl, {\n          reconnectionAttempts: 3,\n          reconnectionDelay: 1000,\n          timeout: 3000\n        });\n        \n        // Create a connection object to track this server\n        const connection = {\n          url: serverUrl,\n          socket: socket,\n          isConnected: false,\n          isLeader: false,\n          serverId: null\n        };\n        \n        connections.push(connection);\n        \n        // Set up connection events\n        socket.on('connect', () => {\n          this.log(`Connected to ${serverUrl} with socket ID: ${socket.id}`);\n          connection.isConnected = true;\n          \n          // Explicitly request initial state to fix \"waiting\" issue\n          socket.emit('requestInitialState');\n          \n          // Ask if this is the leader server\n          socket.emit('checkLeader', {}, (response) => {\n            this.log(`Leader check response from ${serverUrl}:`, response);\n            \n            if (response.isLeader) {\n              this.log(`Server ${serverUrl} is leader with ID: ${response.leaderId}`);\n              \n              // Update connection info\n              connection.isLeader = true;\n              connection.serverId = response.leaderId;\n              \n              // Set this as the active leader if we don't have one yet\n              if (!this.leaderServer) {\n                this.setActiveLeader(connection);\n                \n                // Check for saved session and try to rejoin a room\n                this.attemptRoomRejoin(connection.socket);\n                \n                if (onConnected) {\n                  onConnected(connection.socket);\n                }\n              }\n            } else {\n              this.log(`Server ${serverUrl} is NOT leader (leader is: ${response.leaderId})`);\n              connection.isLeader = false;\n              connection.serverId = response.leaderId;\n              \n              // If we have no connections, use this as a fallback\n              if (!this.leaderServer && !this.activeSocket) {\n                this.setActiveLeader(connection);\n                \n                if (onConnected) {\n                  onConnected(connection.socket);\n                }\n              }\n            }\n          });\n        });\n        \n        // Handle server status changes (leader election changes)\n        socket.on('server-status', (status) => {\n          this.log(`Server status from ${serverUrl}:`, status);\n          connection.isLeader = status.isLeader;\n          connection.serverId = status.serverId;\n          \n          // If this server just became leader, switch to it\n          if (status.isLeader && this.leaderServer !== connection) {\n            this.log(`Server ${serverUrl} became the new leader`);\n            this.setActiveLeader(connection);\n            \n            if (onStateChange) {\n              onStateChange({type: 'leaderChanged', server: connection});\n            }\n            \n            // Try to rejoin existing room if we have session data\n            this.attemptRoomRejoin(connection.socket);\n          }\n        });\n        \n        // Handle disconnect\n        socket.on('disconnect', () => {\n          this.log(`Disconnected from ${serverUrl}`);\n          connection.isConnected = false;\n          \n          // If this was the leader, try to find another leader\n          if (this.leaderServer === connection) {\n            this.log('Leader server disconnected, looking for a new leader...');\n            this.leaderServer = null;\n            this.activeSocket = null;\n            \n            // Find a new leader among connected servers\n            const newLeader = this.servers.find(s => s.isConnected && s.isLeader);\n            if (newLeader) {\n              this.log(`Found new leader: ${newLeader.url}`);\n              this.setActiveLeader(newLeader);\n              \n              if (onStateChange) {\n                onStateChange({type: 'leaderChanged', server: newLeader});\n              }\n              \n              // Try to rejoin existing room\n              this.attemptRoomRejoin(newLeader.socket);\n            } else {\n              // Try any connected server if no leader is found\n              const anyServer = this.servers.find(s => s.isConnected);\n              if (anyServer) {\n                this.log(`No leader found, using connected server: ${anyServer.url}`);\n                this.setActiveLeader(anyServer);\n                \n                if (onStateChange) {\n                  onStateChange({type: 'leaderChanged', server: anyServer});\n                }\n                \n                // Try to rejoin existing room\n                this.attemptRoomRejoin(anyServer.socket);\n              } else {\n                this.log('No servers available. All servers are down.');\n                \n                if (onStateChange) {\n                  onStateChange({type: 'allServersDown'});\n                }\n              }\n            }\n          }\n        });\n        \n        // Setup instance-specific error handler\n        socket.on('connect_error', (error) => {\n          this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        });\n      }\n      \n      // Store all server connections\n      this.servers = connections;\n      \n      return true;\n    } catch (error) {\n      this.log('Error initializing server connections:', error);\n      throw error;\n    }\n  }\n  \n  setActiveLeader(connection) {\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    this.log(`Active leader set to ${connection.url}`);\n    \n    // Set up event forwarding\n    this.forwardEvents(connection.socket);\n    \n    // Request initial state from new leader to fix \"waiting\" issue\n    connection.socket.emit('requestInitialState');\n  }\n  \n  forwardEvents(socket) {\n    // Remove handlers from previous socket\n    for (const [event, handlers] of Object.entries(this.eventHandlers)) {\n      for (const handler of handlers) {\n        if (this.previousSocket) {\n          this.previousSocket.off(event, handler);\n        }\n      }\n    }\n    \n    // Add handlers to new socket\n    for (const [event, handlers] of Object.entries(this.eventHandlers)) {\n      for (const handler of handlers) {\n        socket.on(event, handler);\n      }\n    }\n    \n    this.previousSocket = socket;\n  }\n  \n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (!session || !session.roomCode || this.hasRejoinedRoom) return false;\n    \n    this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n    \n    socket.emit('rejoinRoom', {\n      roomCode: session.roomCode,\n      playerName: session.playerName,\n      previousSocketId: session.socketId\n    });\n    \n    return true;\n  }\n  \n  on(event, callback) {\n    if (!this.eventHandlers[event]) {\n      this.eventHandlers[event] = [];\n    }\n    \n    this.eventHandlers[event].push(callback);\n    \n    // If we already have an active socket, register the handler immediately\n    if (this.activeSocket) {\n      this.activeSocket.on(event, callback);\n    }\n  }\n  \n  emit(event, ...args) {\n    if (!this.activeSocket) {\n      this.log(`Warning: Tried to emit ${event} but no active socket`);\n      return false;\n    }\n    \n    this.activeSocket.emit(event, ...args);\n    return true;\n  }\n  \n  getActiveServer() {\n    return this.leaderServer;\n  }\n  \n  getSocketId() {\n    return this.activeSocket ? this.activeSocket.id : null;\n  }\n  \n  disconnect() {\n    for (const server of this.servers) {\n      if (server.socket) {\n        server.socket.disconnect();\n      }\n    }\n    this.servers = [];\n    this.leaderServer = null;\n    this.activeSocket = null;\n  }\n}\n\n// Create singleton instance\nconst serverManager = new ServerConnectionManager();\n\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}