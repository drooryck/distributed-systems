{"ast":null,"code":"var _jsxFileName = \"/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState, useCallback, useRef } from 'react';\nimport { io } from 'socket.io-client';\nimport { connectToCluster } from './serverDiscovery';\nimport BoardStage from './BoardStage';\nimport NewHomeScreen from './NewHomeScreen';\nimport ReadyScreen from './ReadyScreen';\nimport GameOverScreen from './GameOverScreen';\nimport ScorePanel from './ScorePanel';\nimport './App.css';\n\n// Background image configuration\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst BACKGROUND_IMAGES = ['deep-tetris-color.jpg', 'tetris-1920-x-1080-background-hyihqau5t3lalo4e.png', 'tetris-2560-x-1600-background-3bjbi7nyulqbller.jpg'];\nconst BACKGROUND_CHANGE_INTERVAL = 30000; // 30 seconds\n\n// Load config file to get server address\nconst loadConfig = async () => {\n  try {\n    const response = await fetch('/config.json');\n    if (!response.ok) {\n      throw new Error(`Failed to load config: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.warn('Error loading config, using default server address:', error);\n    return {\n      serverAddress: 'http://localhost:3001'\n    };\n  }\n};\n\n// Debug logging\nconst DEBUG = {\n  events: true,\n  state: true,\n  render: false\n};\nfunction debugLog(type, ...args) {\n  if (DEBUG[type]) {\n    console.log(`[DEBUG:${type}]`, ...args);\n  }\n}\n\n// Function to get current background URL\nconst getBackgroundUrl = index => {\n  return `${process.env.PUBLIC_URL}/backgrounds/${BACKGROUND_IMAGES[index]}`;\n};\n\n// App component\nfunction App() {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [gameState, setGameState] = useState(null);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [gameOverData, setGameOverData] = useState(null);\n  const [isConnecting, setIsConnecting] = useState(true);\n  const [error, setError] = useState(null);\n  const [socketError, setSocketError] = useState(null);\n\n  // Hard‐drop guard so holding space won't repeat\n  const hardDropActiveRef = useRef(false);\n\n  // Add state for background rotation\n  const [currentBackgroundIndex, setCurrentBackgroundIndex] = useState(0);\n  const backgroundIntervalRef = useRef(null);\n\n  // Add state for timer and scoring\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const [currentScore, setCurrentScore] = useState(0);\n  const [lastScoreChange, setLastScoreChange] = useState(0);\n  const [level, setLevel] = useState(1);\n  const timerIntervalRef = useRef(null);\n\n  // For reconnection logic\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectionAttemptsRef = useRef(0);\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const lastGameStateRef = useRef(null);\n\n  // Function to get current background URL\n  const getCurrentBackgroundUrl = () => {\n    return getBackgroundUrl(currentBackgroundIndex);\n  };\n\n  // Connect to socket on component mount\n  useEffect(() => {\n    const connectToServer = async () => {\n      try {\n        setIsConnecting(true);\n        setSocketError(null);\n\n        // Try to connect to the cluster\n        let newSocket;\n        try {\n          debugLog('events', 'Attempting to connect to server cluster');\n          newSocket = await connectToCluster();\n        } catch (clusterError) {\n          var _config$client;\n          debugLog('events', 'Cluster connection failed, falling back to direct connection', clusterError);\n\n          // Fall back to direct connection\n          const config = await loadConfig();\n          const serverAddress = ((_config$client = config.client) === null || _config$client === void 0 ? void 0 : _config$client.serverAddress) || config.serverAddress || 'http://localhost:3001';\n          debugLog('events', 'Connecting to server:', serverAddress);\n          newSocket = io(serverAddress);\n        }\n        setSocket(newSocket);\n\n        // Socket event handlers\n        newSocket.on('connect', () => {\n          debugLog('events', 'Socket connected with ID:', newSocket.id);\n          setIsConnecting(false);\n          setSocketError(null);\n          reconnectionAttemptsRef.current = 0;\n        });\n        newSocket.on('connect_error', err => {\n          debugLog('events', 'Connection error:', err.message);\n          setSocketError(`Connection error: ${err.message}`);\n          setIsConnecting(false);\n        });\n\n        // Handle leader information updates\n        newSocket.on('leaderInfo', info => {\n          debugLog('events', 'Leader info received:', info);\n          if (!info.isLeader && info.leaderAddress) {\n            debugLog('events', 'Redirecting to leader at:', info.leaderAddress);\n\n            // Disconnect from current socket\n            newSocket.disconnect();\n\n            // Connect to the leader\n            const leaderSocket = io(info.leaderAddress);\n            setSocket(leaderSocket);\n\n            // Set up event handlers on the new socket\n            // ...similar handlers as above\n          }\n        });\n\n        // Handle initial state\n        newSocket.on('init', initialState => {\n          debugLog('events', 'Received init event with state:', initialState);\n        });\n\n        // Handle game state updates\n        newSocket.on('gameState', newGameState => {\n          debugLog('state', 'Received gameState update:', newGameState);\n          setGameState(prevState => {\n            // Store the game state for potential reconnection\n            if (newGameState) {\n              lastGameStateRef.current = newGameState;\n            }\n\n            // Special case to prevent accidentally going back to homescreen\n            if ((prevState === null || prevState === void 0 ? void 0 : prevState.appPhase) === 'readyscreen' && (newGameState === null || newGameState === void 0 ? void 0 : newGameState.appPhase) === 'homescreen') {\n              debugLog('state', 'Ignoring homescreen gameState while in readyscreen');\n              return prevState;\n            }\n            return newGameState;\n          });\n\n          // Update score if available\n          if (newGameState && newGameState.appPhase === 'playing') {\n            // Find the player that corresponds to this client\n            const player = newGameState.players[newSocket.id];\n            if (player) {\n              const newScore = player.score || 0;\n              if (newScore !== currentScore) {\n                setLastScoreChange(Date.now());\n                setCurrentScore(newScore);\n              }\n            }\n          }\n        });\n\n        // Handle room creation\n        newSocket.on('roomCreated', ({\n          roomCode,\n          gameState\n        }) => {\n          debugLog('events', `Room created: ${roomCode}`);\n          setGameState(gameState);\n        });\n\n        // Handle joining a room\n        newSocket.on('roomJoined', ({\n          roomCode,\n          gameState\n        }) => {\n          debugLog('events', `Joined room: ${roomCode}`);\n          setGameState(gameState);\n        });\n\n        // Handle player joining\n        newSocket.on('playerJoined', ({\n          playerId,\n          gameState\n        }) => {\n          debugLog('events', `Player joined: ${playerId}`);\n          setGameState(gameState);\n        });\n\n        // Handle player leaving\n        newSocket.on('playerLeft', ({\n          playerId,\n          gameState\n        }) => {\n          debugLog('events', `Player left: ${playerId}`);\n          setGameState(gameState);\n        });\n\n        // Handle host assignment (when previous host leaves)\n        newSocket.on('hostAssigned', ({\n          gameState\n        }) => {\n          debugLog('events', 'You are now the host');\n          setGameState(gameState);\n        });\n\n        // Handle game over\n        newSocket.on('gameOver', data => {\n          debugLog('events', 'Game over:', data);\n          setIsGameOver(true);\n          setGameOverData(data);\n        });\n\n        // Handle server errors\n        newSocket.on('error', err => {\n          debugLog('events', 'Server error:', err);\n          setError(err.message);\n        });\n\n        // Handle disconnection with reconnection logic\n        newSocket.on('disconnect', reason => {\n          debugLog('events', 'Socket disconnected:', reason);\n\n          // If the disconnect was not initiated by the client, attempt to reconnect\n          if (reason === 'io server disconnect' || reason === 'transport close' || reason === 'transport error') {\n            if (reconnectionAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\n              debugLog('events', `Attempting to reconnect (${reconnectionAttemptsRef.current + 1}/${MAX_RECONNECT_ATTEMPTS})...`);\n              setIsConnecting(true);\n\n              // Clear any existing reconnection timeout\n              if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n              }\n\n              // Exponential backoff for reconnection\n              const delay = Math.min(1000 * Math.pow(2, reconnectionAttemptsRef.current), 10000);\n              reconnectTimeoutRef.current = setTimeout(async () => {\n                reconnectionAttemptsRef.current++;\n                connectToServer();\n              }, delay);\n            } else {\n              debugLog('events', 'Max reconnection attempts reached');\n              setSocketError('Could not reconnect to the server. Please refresh the page.');\n              setIsConnecting(false);\n            }\n          }\n        });\n\n        // Return cleanup function\n        return () => {\n          debugLog('events', 'Cleaning up socket connection');\n          if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n          }\n          newSocket.disconnect();\n        };\n      } catch (err) {\n        console.error('Error connecting to server:', err);\n        setSocketError(`Error connecting to server: ${err.message}`);\n        setIsConnecting(false);\n      }\n    };\n    connectToServer();\n  }, []);\n\n  // Background rotation effect - only active during gameplay\n  useEffect(() => {\n    // Clear any existing background rotation interval\n    if (backgroundIntervalRef.current) {\n      clearInterval(backgroundIntervalRef.current);\n      backgroundIntervalRef.current = null;\n    }\n\n    // Start background rotation when game is playing\n    if (gameState && gameState.appPhase === 'playing') {\n      backgroundIntervalRef.current = setInterval(() => {\n        setCurrentBackgroundIndex(prevIndex => (prevIndex + 1) % BACKGROUND_IMAGES.length);\n      }, BACKGROUND_CHANGE_INTERVAL);\n    }\n    return () => {\n      if (backgroundIntervalRef.current) {\n        clearInterval(backgroundIntervalRef.current);\n      }\n    };\n  }, [gameState === null || gameState === void 0 ? void 0 : gameState.appPhase]);\n\n  // Timer effect for gameplay\n  useEffect(() => {\n    if (gameState && gameState.appPhase === 'playing') {\n      if (!timerIntervalRef.current) {\n        const startTime = Date.now();\n        timerIntervalRef.current = setInterval(() => {\n          const elapsed = Math.floor((Date.now() - startTime) / 1000);\n          setElapsedTime(elapsed);\n\n          // Update level based on time (every 30 seconds)\n          const newLevel = Math.max(1, Math.floor(elapsed / 30) + 1);\n          if (newLevel !== level) {\n            setLevel(newLevel);\n          }\n        }, 1000);\n      }\n    } else {\n      // Clear timer when not playing\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n        timerIntervalRef.current = null;\n      }\n\n      // Reset timer and level when game ends\n      if (gameState && gameState.appPhase !== 'playing') {\n        setElapsedTime(0);\n        setLevel(1);\n      }\n    }\n    return () => {\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n      }\n    };\n  }, [gameState === null || gameState === void 0 ? void 0 : gameState.appPhase, level]);\n\n  // Handle keydown events for gameplay\n  const handleKeyDown = useCallback(e => {\n    if (!socket || !gameState || gameState.appPhase !== 'playing') return;\n\n    // Prevent default behavior for game controls\n    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space', 'KeyZ'].includes(e.code)) {\n      e.preventDefault();\n    }\n\n    // Only handle keys that aren't being repeated (except down)\n    if (!e.repeat || e.code === 'ArrowDown') {\n      switch (e.code) {\n        case 'ArrowLeft':\n          // First send immediate move, then start DAS\n          socket.emit('playerAction', {\n            type: 'moveLeft'\n          });\n          socket.emit('playerAction', {\n            type: 'startDAS',\n            direction: 'left'\n          });\n          break;\n        case 'ArrowRight':\n          // First send immediate move, then start DAS\n          socket.emit('playerAction', {\n            type: 'moveRight'\n          });\n          socket.emit('playerAction', {\n            type: 'startDAS',\n            direction: 'right'\n          });\n          break;\n        case 'ArrowUp':\n        case 'KeyZ':\n          socket.emit('playerAction', {\n            type: 'rotate'\n          });\n          break;\n        case 'ArrowDown':\n          socket.emit('playerAction', {\n            type: 'softDrop'\n          });\n          break;\n        case 'Space':\n          // guard against auto‑repeat when holding space\n          if (!hardDropActiveRef.current) {\n            socket.emit('playerAction', {\n              type: 'hardDrop'\n            });\n            hardDropActiveRef.current = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }, [socket, gameState]);\n\n  // Handle keyup events to stop DAS (delayed auto-shift)\n  const handleKeyUp = useCallback(e => {\n    if (!socket || !gameState || gameState.appPhase !== 'playing') return;\n    switch (e.code) {\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        socket.emit('playerAction', {\n          type: 'stopDAS'\n        });\n        break;\n      case 'Space':\n        hardDropActiveRef.current = false;\n        break;\n      default:\n        break;\n    }\n  }, [socket, gameState]);\n\n  // Add key event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handleKeyDown, handleKeyUp]);\n\n  // Create a room\n  const createRoom = useCallback(playerName => {\n    if (socket) {\n      debugLog('events', 'Creating room with player name:', playerName);\n      socket.emit('createRoom', playerName);\n    }\n  }, [socket]);\n\n  // Join a room\n  const joinRoom = useCallback((roomCode, playerName) => {\n    if (socket) {\n      debugLog('events', `Joining room ${roomCode} with player name: ${playerName}`);\n      socket.emit('joinRoom', {\n        roomCode,\n        playerName\n      });\n    }\n  }, [socket]);\n\n  // Leave a room\n  const leaveRoom = useCallback(() => {\n    if (socket) {\n      debugLog('events', 'Leaving room');\n      socket.emit('leaveRoom');\n    }\n  }, [socket]);\n\n  // Set player ready state\n  const setReady = useCallback(isReady => {\n    if (socket) {\n      debugLog('events', `Setting ready state: ${isReady}`);\n      socket.emit('playerReady', isReady);\n    }\n  }, [socket]);\n\n  // Start the game (host only)\n  const startGame = useCallback(() => {\n    if (socket) {\n      debugLog('events', 'Starting game');\n      socket.emit('startGame');\n    }\n  }, [socket]);\n\n  // Show error message if there's a socket error\n  if (socketError) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App error-screen\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Connection Error\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 449,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: socketError\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 450,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Please check that the server is running and the configuration is correct.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 451,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => window.location.reload(),\n        style: {\n          padding: '10px 20px',\n          backgroundColor: '#FF5733',\n          border: 'none',\n          borderRadius: '4px',\n          color: 'white',\n          cursor: 'pointer',\n          marginTop: '20px'\n        },\n        children: \"Retry Connection\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 452,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 448,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Show loading screen if no game state\n  if (!gameState) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App\",\n      children: /*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Waiting for game state...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 472,\n        columnNumber: 33\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 472,\n      columnNumber: 12\n    }, this);\n  }\n\n  // Render appropriate screen based on app phase\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    style: {\n      ...(gameState.appPhase === 'playing' && {\n        backgroundImage: `url(${getCurrentBackgroundUrl()})`,\n        backgroundSize: 'cover',\n        backgroundPosition: 'center'\n      })\n    },\n    children: [gameState.appPhase === 'homescreen' && /*#__PURE__*/_jsxDEV(NewHomeScreen, {\n      onCreateRoom: createRoom,\n      onJoinRoom: joinRoom\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 488,\n      columnNumber: 9\n    }, this), gameState.appPhase === 'readyscreen' && /*#__PURE__*/_jsxDEV(ReadyScreen, {\n      gameState: gameState,\n      socketId: socket ? socket.id : null,\n      onReady: setReady,\n      onLeaveRoom: leaveRoom,\n      onStartGame: startGame\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 495,\n      columnNumber: 9\n    }, this), gameState.appPhase === 'playing' && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(BoardStage, {\n        board: gameState.board,\n        players: gameState.players,\n        socketId: socket ? socket.id : null\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 506,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(ScorePanel, {\n        score: currentScore,\n        lastScoreChange: lastScoreChange,\n        level: level,\n        time: elapsedTime\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 511,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), gameState.appPhase === 'gameover' && /*#__PURE__*/_jsxDEV(GameOverScreen, {\n      gameOverData: gameOverData,\n      onPlayAgain: () => {\n        setIsGameOver(false);\n        leaveRoom();\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 521,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 477,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"LFj+QYhQlR6TVgzkr03n/jUOKCY=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","useCallback","useRef","io","connectToCluster","BoardStage","NewHomeScreen","ReadyScreen","GameOverScreen","ScorePanel","jsxDEV","_jsxDEV","Fragment","_Fragment","BACKGROUND_IMAGES","BACKGROUND_CHANGE_INTERVAL","loadConfig","response","fetch","ok","Error","status","json","error","console","warn","serverAddress","DEBUG","events","state","render","debugLog","type","args","log","getBackgroundUrl","index","process","env","PUBLIC_URL","App","_s","socket","setSocket","gameState","setGameState","isGameOver","setIsGameOver","gameOverData","setGameOverData","isConnecting","setIsConnecting","setError","socketError","setSocketError","hardDropActiveRef","currentBackgroundIndex","setCurrentBackgroundIndex","backgroundIntervalRef","elapsedTime","setElapsedTime","currentScore","setCurrentScore","lastScoreChange","setLastScoreChange","level","setLevel","timerIntervalRef","reconnectTimeoutRef","reconnectionAttemptsRef","MAX_RECONNECT_ATTEMPTS","lastGameStateRef","getCurrentBackgroundUrl","connectToServer","newSocket","clusterError","_config$client","config","client","on","id","current","err","message","info","isLeader","leaderAddress","disconnect","leaderSocket","initialState","newGameState","prevState","appPhase","player","players","newScore","score","Date","now","roomCode","playerId","data","reason","clearTimeout","delay","Math","min","pow","setTimeout","clearInterval","setInterval","prevIndex","length","startTime","elapsed","floor","newLevel","max","handleKeyDown","e","includes","code","preventDefault","repeat","emit","direction","handleKeyUp","window","addEventListener","removeEventListener","createRoom","playerName","joinRoom","leaveRoom","setReady","isReady","startGame","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","location","reload","style","padding","backgroundColor","border","borderRadius","color","cursor","marginTop","backgroundImage","backgroundSize","backgroundPosition","onCreateRoom","onJoinRoom","socketId","onReady","onLeaveRoom","onStartGame","board","time","onPlayAgain","_c","$RefreshReg$"],"sources":["/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/App.js"],"sourcesContent":["import React, { useEffect, useState, useCallback, useRef } from 'react';\nimport { io } from 'socket.io-client';\nimport { connectToCluster } from './serverDiscovery';\nimport BoardStage from './BoardStage';\nimport NewHomeScreen from './NewHomeScreen';\nimport ReadyScreen from './ReadyScreen';\nimport GameOverScreen from './GameOverScreen';\nimport ScorePanel from './ScorePanel';\nimport './App.css';\n\n// Background image configuration\nconst BACKGROUND_IMAGES = [\n  'deep-tetris-color.jpg',\n  'tetris-1920-x-1080-background-hyihqau5t3lalo4e.png',\n  'tetris-2560-x-1600-background-3bjbi7nyulqbller.jpg',\n];\nconst BACKGROUND_CHANGE_INTERVAL = 30000; // 30 seconds\n\n// Load config file to get server address\nconst loadConfig = async () => {\n  try {\n    const response = await fetch('/config.json');\n    if (!response.ok) {\n      throw new Error(`Failed to load config: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.warn('Error loading config, using default server address:', error);\n    return { serverAddress: 'http://localhost:3001' };\n  }\n};\n\n// Debug logging\nconst DEBUG = {\n  events: true,\n  state: true,\n  render: false\n};\n\nfunction debugLog(type, ...args) {\n  if (DEBUG[type]) {\n    console.log(`[DEBUG:${type}]`, ...args);\n  }\n}\n\n// Function to get current background URL\nconst getBackgroundUrl = (index) => {\n  return `${process.env.PUBLIC_URL}/backgrounds/${BACKGROUND_IMAGES[index]}`;\n};\n\n// App component\nfunction App() {\n  const [socket, setSocket] = useState(null);\n  const [gameState, setGameState] = useState(null);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [gameOverData, setGameOverData] = useState(null);\n  const [isConnecting, setIsConnecting] = useState(true);\n  const [error, setError] = useState(null);\n  const [socketError, setSocketError] = useState(null);\n\n  // Hard‐drop guard so holding space won't repeat\n  const hardDropActiveRef = useRef(false);\n\n  // Add state for background rotation\n  const [currentBackgroundIndex, setCurrentBackgroundIndex] = useState(0);\n  const backgroundIntervalRef = useRef(null);\n\n  // Add state for timer and scoring\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const [currentScore, setCurrentScore] = useState(0);\n  const [lastScoreChange, setLastScoreChange] = useState(0);\n  const [level, setLevel] = useState(1);\n  const timerIntervalRef = useRef(null);\n\n  // For reconnection logic\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectionAttemptsRef = useRef(0);\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const lastGameStateRef = useRef(null);\n\n  // Function to get current background URL\n  const getCurrentBackgroundUrl = () => {\n    return getBackgroundUrl(currentBackgroundIndex);\n  };\n\n  // Connect to socket on component mount\n  useEffect(() => {\n    const connectToServer = async () => {\n      try {\n        setIsConnecting(true);\n        setSocketError(null);\n\n        // Try to connect to the cluster\n        let newSocket;\n        try {\n          debugLog('events', 'Attempting to connect to server cluster');\n          newSocket = await connectToCluster();\n        } catch (clusterError) {\n          debugLog('events', 'Cluster connection failed, falling back to direct connection', clusterError);\n          \n          // Fall back to direct connection\n          const config = await loadConfig();\n          const serverAddress = config.client?.serverAddress || config.serverAddress || 'http://localhost:3001';\n          \n          debugLog('events', 'Connecting to server:', serverAddress);\n          newSocket = io(serverAddress);\n        }\n        \n        setSocket(newSocket);\n\n        // Socket event handlers\n        newSocket.on('connect', () => {\n          debugLog('events', 'Socket connected with ID:', newSocket.id);\n          setIsConnecting(false);\n          setSocketError(null);\n          reconnectionAttemptsRef.current = 0;\n        });\n\n        newSocket.on('connect_error', (err) => {\n          debugLog('events', 'Connection error:', err.message);\n          setSocketError(`Connection error: ${err.message}`);\n          setIsConnecting(false);\n        });\n\n        // Handle leader information updates\n        newSocket.on('leaderInfo', (info) => {\n          debugLog('events', 'Leader info received:', info);\n          \n          if (!info.isLeader && info.leaderAddress) {\n            debugLog('events', 'Redirecting to leader at:', info.leaderAddress);\n            \n            // Disconnect from current socket\n            newSocket.disconnect();\n            \n            // Connect to the leader\n            const leaderSocket = io(info.leaderAddress);\n            setSocket(leaderSocket);\n            \n            // Set up event handlers on the new socket\n            // ...similar handlers as above\n          }\n        });\n\n        // Handle initial state\n        newSocket.on('init', (initialState) => {\n          debugLog('events', 'Received init event with state:', initialState);\n        });\n\n        // Handle game state updates\n        newSocket.on('gameState', (newGameState) => {\n          debugLog('state', 'Received gameState update:', newGameState);\n          \n          setGameState((prevState) => {\n            // Store the game state for potential reconnection\n            if (newGameState) {\n              lastGameStateRef.current = newGameState;\n            }\n            \n            // Special case to prevent accidentally going back to homescreen\n            if (prevState?.appPhase === 'readyscreen' && newGameState?.appPhase === 'homescreen') {\n              debugLog('state', 'Ignoring homescreen gameState while in readyscreen');\n              return prevState;\n            }\n            \n            return newGameState;\n          });\n          \n          // Update score if available\n          if (newGameState && newGameState.appPhase === 'playing') {\n            // Find the player that corresponds to this client\n            const player = newGameState.players[newSocket.id];\n            if (player) {\n              const newScore = player.score || 0;\n              if (newScore !== currentScore) {\n                setLastScoreChange(Date.now());\n                setCurrentScore(newScore);\n              }\n            }\n          }\n        });\n\n        // Handle room creation\n        newSocket.on('roomCreated', ({ roomCode, gameState }) => {\n          debugLog('events', `Room created: ${roomCode}`);\n          setGameState(gameState);\n        });\n\n        // Handle joining a room\n        newSocket.on('roomJoined', ({ roomCode, gameState }) => {\n          debugLog('events', `Joined room: ${roomCode}`);\n          setGameState(gameState);\n        });\n\n        // Handle player joining\n        newSocket.on('playerJoined', ({ playerId, gameState }) => {\n          debugLog('events', `Player joined: ${playerId}`);\n          setGameState(gameState);\n        });\n\n        // Handle player leaving\n        newSocket.on('playerLeft', ({ playerId, gameState }) => {\n          debugLog('events', `Player left: ${playerId}`);\n          setGameState(gameState);\n        });\n        \n        // Handle host assignment (when previous host leaves)\n        newSocket.on('hostAssigned', ({ gameState }) => {\n          debugLog('events', 'You are now the host');\n          setGameState(gameState);\n        });\n\n        // Handle game over\n        newSocket.on('gameOver', (data) => {\n          debugLog('events', 'Game over:', data);\n          setIsGameOver(true);\n          setGameOverData(data);\n        });\n\n        // Handle server errors\n        newSocket.on('error', (err) => {\n          debugLog('events', 'Server error:', err);\n          setError(err.message);\n        });\n\n        // Handle disconnection with reconnection logic\n        newSocket.on('disconnect', (reason) => {\n          debugLog('events', 'Socket disconnected:', reason);\n          \n          // If the disconnect was not initiated by the client, attempt to reconnect\n          if (reason === 'io server disconnect' || reason === 'transport close' || reason === 'transport error') {\n            if (reconnectionAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\n              debugLog('events', `Attempting to reconnect (${reconnectionAttemptsRef.current + 1}/${MAX_RECONNECT_ATTEMPTS})...`);\n              setIsConnecting(true);\n              \n              // Clear any existing reconnection timeout\n              if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n              }\n              \n              // Exponential backoff for reconnection\n              const delay = Math.min(1000 * Math.pow(2, reconnectionAttemptsRef.current), 10000);\n              reconnectTimeoutRef.current = setTimeout(async () => {\n                reconnectionAttemptsRef.current++;\n                connectToServer();\n              }, delay);\n            } else {\n              debugLog('events', 'Max reconnection attempts reached');\n              setSocketError('Could not reconnect to the server. Please refresh the page.');\n              setIsConnecting(false);\n            }\n          }\n        });\n\n        // Return cleanup function\n        return () => {\n          debugLog('events', 'Cleaning up socket connection');\n          \n          if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n          }\n          \n          newSocket.disconnect();\n        };\n      } catch (err) {\n        console.error('Error connecting to server:', err);\n        setSocketError(`Error connecting to server: ${err.message}`);\n        setIsConnecting(false);\n      }\n    };\n\n    connectToServer();\n  }, []);\n\n  // Background rotation effect - only active during gameplay\n  useEffect(() => {\n    // Clear any existing background rotation interval\n    if (backgroundIntervalRef.current) {\n      clearInterval(backgroundIntervalRef.current);\n      backgroundIntervalRef.current = null;\n    }\n\n    // Start background rotation when game is playing\n    if (gameState && gameState.appPhase === 'playing') {\n      backgroundIntervalRef.current = setInterval(() => {\n        setCurrentBackgroundIndex((prevIndex) => \n          (prevIndex + 1) % BACKGROUND_IMAGES.length\n        );\n      }, BACKGROUND_CHANGE_INTERVAL);\n    }\n\n    return () => {\n      if (backgroundIntervalRef.current) {\n        clearInterval(backgroundIntervalRef.current);\n      }\n    };\n  }, [gameState?.appPhase]);\n\n  // Timer effect for gameplay\n  useEffect(() => {\n    if (gameState && gameState.appPhase === 'playing') {\n      if (!timerIntervalRef.current) {\n        const startTime = Date.now();\n        timerIntervalRef.current = setInterval(() => {\n          const elapsed = Math.floor((Date.now() - startTime) / 1000);\n          setElapsedTime(elapsed);\n          \n          // Update level based on time (every 30 seconds)\n          const newLevel = Math.max(1, Math.floor(elapsed / 30) + 1);\n          if (newLevel !== level) {\n            setLevel(newLevel);\n          }\n        }, 1000);\n      }\n    } else {\n      // Clear timer when not playing\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n        timerIntervalRef.current = null;\n      }\n      \n      // Reset timer and level when game ends\n      if (gameState && gameState.appPhase !== 'playing') {\n        setElapsedTime(0);\n        setLevel(1);\n      }\n    }\n    \n    return () => {\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n      }\n    };\n  }, [gameState?.appPhase, level]);\n\n  // Handle keydown events for gameplay\n  const handleKeyDown = useCallback((e) => {\n    if (!socket || !gameState || gameState.appPhase !== 'playing') return;\n\n    // Prevent default behavior for game controls\n    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space', 'KeyZ'].includes(e.code)) {\n      e.preventDefault();\n    }\n\n    // Only handle keys that aren't being repeated (except down)\n    if (!e.repeat || e.code === 'ArrowDown') {\n      switch (e.code) {\n        case 'ArrowLeft':\n          // First send immediate move, then start DAS\n          socket.emit('playerAction', { type: 'moveLeft' });\n          socket.emit('playerAction', { type: 'startDAS', direction: 'left' });\n          break;\n        case 'ArrowRight':\n          // First send immediate move, then start DAS\n          socket.emit('playerAction', { type: 'moveRight' });\n          socket.emit('playerAction', { type: 'startDAS', direction: 'right' });\n          break;\n        case 'ArrowUp':\n        case 'KeyZ':\n          socket.emit('playerAction', { type: 'rotate' });\n          break;\n        case 'ArrowDown':\n          socket.emit('playerAction', { type: 'softDrop' });\n          break;\n        case 'Space':\n          // guard against auto‑repeat when holding space\n          if (!hardDropActiveRef.current) {\n            socket.emit('playerAction', { type: 'hardDrop' });\n            hardDropActiveRef.current = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }, [socket, gameState]);\n\n  // Handle keyup events to stop DAS (delayed auto-shift)\n  const handleKeyUp = useCallback((e) => {\n    if (!socket || !gameState || gameState.appPhase !== 'playing') return;\n    \n    switch (e.code) {\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        socket.emit('playerAction', { type: 'stopDAS' });\n        break;\n      case 'Space':\n        hardDropActiveRef.current = false;\n        break;\n      default:\n        break;\n    }\n  }, [socket, gameState]);\n\n  // Add key event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    \n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handleKeyDown, handleKeyUp]);\n\n  // Create a room\n  const createRoom = useCallback((playerName) => {\n    if (socket) {\n      debugLog('events', 'Creating room with player name:', playerName);\n      socket.emit('createRoom', playerName);\n    }\n  }, [socket]);\n\n  // Join a room\n  const joinRoom = useCallback((roomCode, playerName) => {\n    if (socket) {\n      debugLog('events', `Joining room ${roomCode} with player name: ${playerName}`);\n      socket.emit('joinRoom', { roomCode, playerName });\n    }\n  }, [socket]);\n\n  // Leave a room\n  const leaveRoom = useCallback(() => {\n    if (socket) {\n      debugLog('events', 'Leaving room');\n      socket.emit('leaveRoom');\n    }\n  }, [socket]);\n\n  // Set player ready state\n  const setReady = useCallback((isReady) => {\n    if (socket) {\n      debugLog('events', `Setting ready state: ${isReady}`);\n      socket.emit('playerReady', isReady);\n    }\n  }, [socket]);\n\n  // Start the game (host only)\n  const startGame = useCallback(() => {\n    if (socket) {\n      debugLog('events', 'Starting game');\n      socket.emit('startGame');\n    }\n  }, [socket]);\n\n  // Show error message if there's a socket error\n  if (socketError) {\n    return (\n      <div className=\"App error-screen\">\n        <h1>Connection Error</h1>\n        <p>{socketError}</p>\n        <p>Please check that the server is running and the configuration is correct.</p>\n        <button\n          onClick={() => window.location.reload()}\n          style={{\n            padding: '10px 20px',\n            backgroundColor: '#FF5733',\n            border: 'none',\n            borderRadius: '4px',\n            color: 'white',\n            cursor: 'pointer',\n            marginTop: '20px'\n          }}\n        >\n          Retry Connection\n        </button>\n      </div>\n    );\n  }\n\n  // Show loading screen if no game state\n  if (!gameState) {\n    return <div className=\"App\"><h1>Waiting for game state...</h1></div>;\n  }\n\n  // Render appropriate screen based on app phase\n  return (\n    <div\n      className=\"App\"\n      style={{\n        ...(gameState.appPhase === 'playing' && {\n          backgroundImage: `url(${getCurrentBackgroundUrl()})`,\n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n        }),\n      }}\n    >\n      {gameState.appPhase === 'homescreen' && (\n        <NewHomeScreen\n          onCreateRoom={createRoom}\n          onJoinRoom={joinRoom}\n        />\n      )}\n      \n      {gameState.appPhase === 'readyscreen' && (\n        <ReadyScreen\n          gameState={gameState}\n          socketId={socket ? socket.id : null}\n          onReady={setReady}\n          onLeaveRoom={leaveRoom}\n          onStartGame={startGame}\n        />\n      )}\n      \n      {gameState.appPhase === 'playing' && (\n        <>\n          <BoardStage\n            board={gameState.board}\n            players={gameState.players}\n            socketId={socket ? socket.id : null}\n          />\n          <ScorePanel\n            score={currentScore}\n            lastScoreChange={lastScoreChange}\n            level={level}\n            time={elapsedTime}\n          />\n        </>\n      )}\n      \n      {gameState.appPhase === 'gameover' && (\n        <GameOverScreen\n          gameOverData={gameOverData}\n          onPlayAgain={() => {\n            setIsGameOver(false);\n            leaveRoom();\n          }}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}