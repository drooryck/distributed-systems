{"ast":null,"code":"var _jsxFileName = \"/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/GameBoard.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\n\n// Map of tetromino values to colors\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst COLORS = {\n  1: 'cyan',\n  // I\n  2: 'blue',\n  // J\n  3: 'orange',\n  // L\n  4: 'yellow',\n  // O\n  5: 'green',\n  // S\n  6: 'purple',\n  // T\n  7: 'red' // Z\n};\nfunction GameBoard({\n  board,\n  players,\n  currentPlayerId\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const cellSize = 30; // each cell is 30px\n\n  // Calculate canvas dimensions based on board size\n  const canvasWidth = board[0] ? board[0].length * cellSize : 300;\n  const canvasHeight = board.length * cellSize || 600;\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw a dark background\n    ctx.fillStyle = '#111';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw the grid\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 0.5;\n\n    // Draw grid lines\n    for (let r = 0; r <= board.length; r++) {\n      ctx.beginPath();\n      ctx.moveTo(0, r * cellSize);\n      ctx.lineTo(canvas.width, r * cellSize);\n      ctx.stroke();\n    }\n    for (let c = 0; c <= board[0].length; c++) {\n      ctx.beginPath();\n      ctx.moveTo(c * cellSize, 0);\n      ctx.lineTo(c * cellSize, canvas.height);\n      ctx.stroke();\n    }\n\n    // Draw placed pieces on the board\n    for (let r = 0; r < board.length; r++) {\n      for (let c = 0; c < board[r].length; c++) {\n        const cell = board[r][c];\n        if (cell !== 0) {\n          // If the cell has a complex structure (from server)\n          if (typeof cell === 'object') {\n            const playerId = cell.playerId;\n            const player = Object.values(players).find(p => p.id === playerId.substring(0, 4));\n            ctx.fillStyle = player ? player.color : 'gray';\n          } else {\n            // If it's just a number (simple case)\n            ctx.fillStyle = COLORS[cell] || 'gray';\n          }\n          ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);\n          ctx.strokeStyle = '#FFF';\n          ctx.lineWidth = 1;\n          ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);\n        }\n      }\n    }\n\n    // Draw line clear animation if active\n    if (board && Array.isArray(board.linesToClear) && board.linesToClear.length > 0) {\n      board.linesToClear.forEach(rowIndex => {\n        // Flash or highlight the rows being cleared\n        const flash = Math.floor(Date.now() / 100) % 2 === 0;\n        ctx.fillStyle = flash ? '#FFFFFF' : '#888888';\n        ctx.fillRect(0, rowIndex * cellSize, canvas.width, cellSize);\n      });\n    }\n\n    // Draw active tetromino for each player\n    Object.values(players).forEach(player => {\n      const {\n        x,\n        y,\n        currentPiece,\n        color\n      } = player;\n      if (!currentPiece) return;\n      const shape = currentPiece.shape;\n      for (let r = 0; r < shape.length; r++) {\n        for (let c = 0; c < shape[r].length; c++) {\n          if (shape[r][c] !== 0) {\n            const boardX = x + c;\n            const boardY = y + r;\n\n            // Skip if out of bounds or above the board\n            if (boardX < 0 || boardX >= board[0].length || boardY < 0 || boardY >= board.length) {\n              continue;\n            }\n            ctx.fillStyle = color || currentPiece.color || 'gray';\n            ctx.fillRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n            ctx.strokeStyle = '#FFF';\n            ctx.lineWidth = 1;\n            ctx.strokeRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n          }\n        }\n      }\n    });\n  }, [board, players, currentPlayerId]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: 300 // 10 columns * 30 px\n      ,\n      height: 600 // 20 rows * 30 px\n      ,\n      style: {\n        border: '2px solid #555'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 121,\n    columnNumber: 5\n  }, this);\n}\n_s(GameBoard, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = GameBoard;\nexport default GameBoard;\nvar _c;\n$RefreshReg$(_c, \"GameBoard\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","COLORS","GameBoard","board","players","currentPlayerId","_s","canvasRef","cellSize","canvasWidth","length","canvasHeight","canvas","current","ctx","getContext","clearRect","width","height","fillStyle","fillRect","strokeStyle","lineWidth","r","beginPath","moveTo","lineTo","stroke","c","cell","playerId","player","Object","values","find","p","id","substring","color","strokeRect","Array","isArray","linesToClear","forEach","rowIndex","flash","Math","floor","Date","now","x","y","currentPiece","shape","boardX","boardY","children","ref","style","border","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/GameBoard.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\n\n// Map of tetromino values to colors\nconst COLORS = {\n  1: 'cyan',    // I\n  2: 'blue',    // J\n  3: 'orange',  // L\n  4: 'yellow',  // O\n  5: 'green',   // S\n  6: 'purple',  // T\n  7: 'red'      // Z\n};\n\nfunction GameBoard({ board, players, currentPlayerId }) {\n  const canvasRef = useRef(null);\n  const cellSize = 30; // each cell is 30px\n  \n  // Calculate canvas dimensions based on board size\n  const canvasWidth = board[0] ? board[0].length * cellSize : 300;\n  const canvasHeight = board.length * cellSize || 600;\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    \n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw a dark background\n    ctx.fillStyle = '#111';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw the grid\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 0.5;\n    \n    // Draw grid lines\n    for (let r = 0; r <= board.length; r++) {\n      ctx.beginPath();\n      ctx.moveTo(0, r * cellSize);\n      ctx.lineTo(canvas.width, r * cellSize);\n      ctx.stroke();\n    }\n    \n    for (let c = 0; c <= board[0].length; c++) {\n      ctx.beginPath();\n      ctx.moveTo(c * cellSize, 0);\n      ctx.lineTo(c * cellSize, canvas.height);\n      ctx.stroke();\n    }\n    \n    // Draw placed pieces on the board\n    for (let r = 0; r < board.length; r++) {\n      for (let c = 0; c < board[r].length; c++) {\n        const cell = board[r][c];\n        if (cell !== 0) {\n          // If the cell has a complex structure (from server)\n          if (typeof cell === 'object') {\n            const playerId = cell.playerId;\n            const player = Object.values(players).find(p => p.id === playerId.substring(0, 4));\n            ctx.fillStyle = player ? player.color : 'gray';\n          } else {\n            // If it's just a number (simple case)\n            ctx.fillStyle = COLORS[cell] || 'gray';\n          }\n          \n          ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);\n          ctx.strokeStyle = '#FFF';\n          ctx.lineWidth = 1;\n          ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);\n        }\n      }\n    }\n\n  // Draw line clear animation if active\n  if (board && Array.isArray(board.linesToClear) && board.linesToClear.length > 0) {\n    board.linesToClear.forEach(rowIndex => {\n      // Flash or highlight the rows being cleared\n      const flash = Math.floor(Date.now() / 100) % 2 === 0;\n      ctx.fillStyle = flash ? '#FFFFFF' : '#888888';\n      \n      ctx.fillRect(0, rowIndex * cellSize, canvas.width, cellSize);\n    });\n  }\n      \n    // Draw active tetromino for each player\n    Object.values(players).forEach(player => {\n      const { x, y, currentPiece, color } = player;\n      \n      if (!currentPiece) return;\n      \n      const shape = currentPiece.shape;\n      \n      for (let r = 0; r < shape.length; r++) {\n        for (let c = 0; c < shape[r].length; c++) {\n          if (shape[r][c] !== 0) {\n            const boardX = x + c;\n            const boardY = y + r;\n            \n            // Skip if out of bounds or above the board\n            if (boardX < 0 || boardX >= board[0].length || \n                boardY < 0 || boardY >= board.length) {\n              continue;\n            }\n            \n            ctx.fillStyle = color || currentPiece.color || 'gray';\n            ctx.fillRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n            ctx.strokeStyle = '#FFF';\n            ctx.lineWidth = 1;\n            ctx.strokeRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n          }\n        }\n      }\n    });\n    \n  }, [board, players, currentPlayerId]);\n\n  return (\n    <div>\n      <canvas\n        ref={canvasRef}\n        width={300}  // 10 columns * 30 px\n        height={600} // 20 rows * 30 px\n        style={{ border: '2px solid #555' }}\n      />\n    </div>\n  );\n}\n\nexport default GameBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}