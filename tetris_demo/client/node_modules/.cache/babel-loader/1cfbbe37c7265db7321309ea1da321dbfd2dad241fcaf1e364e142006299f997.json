{"ast":null,"code":"var _jsxFileName = \"/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/GameBoard.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\n\n// Map of tetromino values to colors\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst COLORS = {\n  1: 'cyan',\n  // I\n  2: 'blue',\n  // J\n  3: 'orange',\n  // L\n  4: 'yellow',\n  // O\n  5: 'green',\n  // S\n  6: 'purple',\n  // T\n  7: 'red' // Z\n};\nfunction GameBoard({\n  board,\n  players,\n  currentPlayerId\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw a dark background\n    ctx.fillStyle = '#111';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw the grid\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 0.5;\n    const cellSize = 30; // each cell is 30px\n\n    // Draw grid lines\n    for (let r = 0; r <= board.length; r++) {\n      ctx.beginPath();\n      ctx.moveTo(0, r * cellSize);\n      ctx.lineTo(canvas.width, r * cellSize);\n      ctx.stroke();\n    }\n    for (let c = 0; c <= board[0].length; c++) {\n      ctx.beginPath();\n      ctx.moveTo(c * cellSize, 0);\n      ctx.lineTo(c * cellSize, canvas.height);\n      ctx.stroke();\n    }\n\n    // Draw placed pieces on the board\n    for (let r = 0; r < board.length; r++) {\n      for (let c = 0; c < board[r].length; c++) {\n        const cell = board[r][c];\n        if (cell !== 0) {\n          // If the cell has a complex structure (from server)\n          if (typeof cell === 'object') {\n            const playerId = cell.playerId;\n            const player = Object.values(players).find(p => p.id === playerId.substring(0, 4));\n            ctx.fillStyle = player ? player.color : 'gray';\n          } else {\n            // If it's just a number (simple case)\n            ctx.fillStyle = COLORS[cell] || 'gray';\n          }\n          ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);\n          ctx.strokeStyle = '#FFF';\n          ctx.lineWidth = 1;\n          ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);\n        }\n      }\n    }\n\n    // Draw line clear animation if active\n    if (board && Array.isArray(board.linesToClear) && board.linesToClear.length > 0) {\n      board.linesToClear.forEach(rowIndex => {\n        // Flash or highlight the rows being cleared\n        const flash = Math.floor(Date.now() / 100) % 2 === 0;\n        ctx.fillStyle = flash ? '#FFFFFF' : '#888888';\n        ctx.fillRect(0, rowIndex * cellSize, canvas.width, cellSize);\n      });\n    }\n\n    // Draw active tetromino for each player\n    Object.values(players).forEach(player => {\n      const {\n        x,\n        y,\n        currentPiece,\n        color\n      } = player;\n      if (!currentPiece) return;\n      const shape = currentPiece.shape;\n      for (let r = 0; r < shape.length; r++) {\n        for (let c = 0; c < shape[r].length; c++) {\n          if (shape[r][c] !== 0) {\n            const boardX = x + c;\n            const boardY = y + r;\n\n            // Skip if out of bounds or above the board\n            if (boardX < 0 || boardX >= board[0].length || boardY < 0 || boardY >= board.length) {\n              continue;\n            }\n            ctx.fillStyle = color || currentPiece.color || 'gray';\n            ctx.fillRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n            ctx.strokeStyle = '#FFF';\n            ctx.lineWidth = 1;\n            ctx.strokeRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n          }\n        }\n      }\n    });\n  }, [board, players, currentPlayerId]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: 300 // 10 columns * 30 px\n      ,\n      height: 600 // 20 rows * 30 px\n      ,\n      style: {\n        border: '2px solid #555'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 118,\n    columnNumber: 5\n  }, this);\n}\n_s(GameBoard, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = GameBoard;\nexport default GameBoard;\nvar _c;\n$RefreshReg$(_c, \"GameBoard\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","COLORS","GameBoard","board","players","currentPlayerId","_s","canvasRef","canvas","current","ctx","getContext","clearRect","width","height","fillStyle","fillRect","strokeStyle","lineWidth","cellSize","r","length","beginPath","moveTo","lineTo","stroke","c","cell","playerId","player","Object","values","find","p","id","substring","color","strokeRect","Array","isArray","linesToClear","forEach","rowIndex","flash","Math","floor","Date","now","x","y","currentPiece","shape","boardX","boardY","children","ref","style","border","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/GameBoard.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\n\n// Map of tetromino values to colors\nconst COLORS = {\n  1: 'cyan',    // I\n  2: 'blue',    // J\n  3: 'orange',  // L\n  4: 'yellow',  // O\n  5: 'green',   // S\n  6: 'purple',  // T\n  7: 'red'      // Z\n};\n\nfunction GameBoard({ board, players, currentPlayerId }) {\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    \n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw a dark background\n    ctx.fillStyle = '#111';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw the grid\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 0.5;\n    \n    const cellSize = 30; // each cell is 30px\n    \n    // Draw grid lines\n    for (let r = 0; r <= board.length; r++) {\n      ctx.beginPath();\n      ctx.moveTo(0, r * cellSize);\n      ctx.lineTo(canvas.width, r * cellSize);\n      ctx.stroke();\n    }\n    \n    for (let c = 0; c <= board[0].length; c++) {\n      ctx.beginPath();\n      ctx.moveTo(c * cellSize, 0);\n      ctx.lineTo(c * cellSize, canvas.height);\n      ctx.stroke();\n    }\n    \n    // Draw placed pieces on the board\n    for (let r = 0; r < board.length; r++) {\n      for (let c = 0; c < board[r].length; c++) {\n        const cell = board[r][c];\n        if (cell !== 0) {\n          // If the cell has a complex structure (from server)\n          if (typeof cell === 'object') {\n            const playerId = cell.playerId;\n            const player = Object.values(players).find(p => p.id === playerId.substring(0, 4));\n            ctx.fillStyle = player ? player.color : 'gray';\n          } else {\n            // If it's just a number (simple case)\n            ctx.fillStyle = COLORS[cell] || 'gray';\n          }\n          \n          ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);\n          ctx.strokeStyle = '#FFF';\n          ctx.lineWidth = 1;\n          ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);\n        }\n      }\n    }\n\n  // Draw line clear animation if active\n  if (board && Array.isArray(board.linesToClear) && board.linesToClear.length > 0) {\n    board.linesToClear.forEach(rowIndex => {\n      // Flash or highlight the rows being cleared\n      const flash = Math.floor(Date.now() / 100) % 2 === 0;\n      ctx.fillStyle = flash ? '#FFFFFF' : '#888888';\n      \n      ctx.fillRect(0, rowIndex * cellSize, canvas.width, cellSize);\n    });\n  }\n      \n    // Draw active tetromino for each player\n    Object.values(players).forEach(player => {\n      const { x, y, currentPiece, color } = player;\n      \n      if (!currentPiece) return;\n      \n      const shape = currentPiece.shape;\n      \n      for (let r = 0; r < shape.length; r++) {\n        for (let c = 0; c < shape[r].length; c++) {\n          if (shape[r][c] !== 0) {\n            const boardX = x + c;\n            const boardY = y + r;\n            \n            // Skip if out of bounds or above the board\n            if (boardX < 0 || boardX >= board[0].length || \n                boardY < 0 || boardY >= board.length) {\n              continue;\n            }\n            \n            ctx.fillStyle = color || currentPiece.color || 'gray';\n            ctx.fillRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n            ctx.strokeStyle = '#FFF';\n            ctx.lineWidth = 1;\n            ctx.strokeRect(boardX * cellSize, boardY * cellSize, cellSize, cellSize);\n          }\n        }\n      }\n    });\n    \n  }, [board, players, currentPlayerId]);\n\n  return (\n    <div>\n      <canvas\n        ref={canvasRef}\n        width={300}  // 10 columns * 30 px\n        height={600} // 20 rows * 30 px\n        style={{ border: '2px solid #555' }}\n      />\n    </div>\n  );\n}\n\nexport default GameBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}