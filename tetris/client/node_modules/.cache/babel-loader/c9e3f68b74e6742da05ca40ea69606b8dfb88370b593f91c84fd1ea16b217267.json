{"ast":null,"code":"import { io } from 'socket.io-client';\n\n/**\n * Connect to the cluster of servers with automatic leader discovery\n * Attempts to connect to each server in sequence until it finds the leader\n */\nexport async function connectToCluster() {\n  try {\n    // Load cluster configuration\n    const response = await fetch('/config.json');\n    const config = await response.json();\n\n    // Use default server address if available\n    const defaultServer = config.serverAddress || 'http://localhost:3001';\n\n    // Try connecting to the default server first\n    try {\n      console.log(`Trying to connect to default server: ${defaultServer}`);\n      const socket = io(defaultServer, {\n        timeout: 5000\n      });\n\n      // Wait to see if this connection succeeds\n      const result = await new Promise((resolve, reject) => {\n        let timeoutId = setTimeout(() => {\n          socket.disconnect();\n          reject(new Error(`Connection to ${defaultServer} timed out`));\n        }, 5000);\n        socket.on('connect', () => {\n          socket.emit('getLeaderInfo');\n        });\n        socket.on('leaderInfo', info => {\n          clearTimeout(timeoutId);\n          if (info.isLeader) {\n            console.log(`Connected to leader at ${defaultServer}`);\n            resolve({\n              socket,\n              redirect: false\n            });\n          } else if (info.leaderAddress) {\n            console.log(`Redirecting to leader at ${info.leaderAddress}`);\n            socket.disconnect();\n            resolve({\n              socket: null,\n              redirect: true,\n              redirectTo: info.leaderAddress\n            });\n          } else {\n            socket.disconnect();\n            reject(new Error('No leader information available'));\n          }\n        });\n        socket.on('connect_error', err => {\n          clearTimeout(timeoutId);\n          socket.disconnect();\n          reject(err);\n        });\n      });\n\n      // If we need to redirect to the leader\n      if (result.redirect) {\n        return io(result.redirectTo);\n      }\n      return result.socket;\n    } catch (defaultServerError) {\n      console.warn('Failed to connect to default server:', defaultServerError);\n\n      // If we have multiple servers configured, try them in sequence\n      if (config.clusterServers && Array.isArray(config.clusterServers) && config.clusterServers.length > 0) {\n        for (const serverUrl of config.clusterServers) {\n          try {\n            console.log(`Trying to connect to ${serverUrl}`);\n            const socket = io(serverUrl, {\n              timeout: 3000\n            });\n\n            // Wait to see if this connection succeeds\n            const result = await new Promise((resolve, reject) => {\n              let timeoutId = setTimeout(() => {\n                socket.disconnect();\n                reject(new Error(`Connection to ${serverUrl} timed out`));\n              }, 3000);\n              socket.on('connect', () => {\n                socket.emit('getLeaderInfo');\n              });\n              socket.on('leaderInfo', info => {\n                clearTimeout(timeoutId);\n                if (info.isLeader) {\n                  console.log(`Connected to leader at ${serverUrl}`);\n                  resolve({\n                    socket,\n                    redirect: false\n                  });\n                } else if (info.leaderAddress) {\n                  console.log(`Redirecting to leader at ${info.leaderAddress}`);\n                  socket.disconnect();\n                  resolve({\n                    socket: null,\n                    redirect: true,\n                    redirectTo: info.leaderAddress\n                  });\n                } else {\n                  socket.disconnect();\n                  reject(new Error('No leader information available'));\n                }\n              });\n              socket.on('connect_error', err => {\n                clearTimeout(timeoutId);\n                socket.disconnect();\n                reject(err);\n              });\n            });\n\n            // If we need to redirect to the leader\n            if (result.redirect) {\n              return io(result.redirectTo);\n            }\n            return result.socket;\n          } catch (error) {\n            console.warn(`Failed to connect to ${serverUrl}:`, error);\n            // Continue trying next server\n          }\n        }\n      }\n\n      // If all attempts fail, throw an error\n      throw new Error('Could not connect to any server in the cluster');\n    }\n  } catch (error) {\n    console.error('Server discovery failed:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["io","connectToCluster","response","fetch","config","json","defaultServer","serverAddress","console","log","socket","timeout","result","Promise","resolve","reject","timeoutId","setTimeout","disconnect","Error","on","emit","info","clearTimeout","isLeader","redirect","leaderAddress","redirectTo","err","defaultServerError","warn","clusterServers","Array","isArray","length","serverUrl","error"],"sources":["/Users/driesrooryck/Desktop/s25/distributed-systems/tetris/client/src/serverDiscovery.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\n/**\n * Connect to the cluster of servers with automatic leader discovery\n * Attempts to connect to each server in sequence until it finds the leader\n */\nexport async function connectToCluster() {\n  try {\n    // Load cluster configuration\n    const response = await fetch('/config.json');\n    const config = await response.json();\n    \n    // Use default server address if available\n    const defaultServer = config.serverAddress || 'http://localhost:3001';\n    \n    // Try connecting to the default server first\n    try {\n      console.log(`Trying to connect to default server: ${defaultServer}`);\n      const socket = io(defaultServer, { timeout: 5000 });\n      \n      // Wait to see if this connection succeeds\n      const result = await new Promise((resolve, reject) => {\n        let timeoutId = setTimeout(() => {\n          socket.disconnect();\n          reject(new Error(`Connection to ${defaultServer} timed out`));\n        }, 5000);\n        \n        socket.on('connect', () => {\n          socket.emit('getLeaderInfo');\n        });\n        \n        socket.on('leaderInfo', (info) => {\n          clearTimeout(timeoutId);\n          if (info.isLeader) {\n            console.log(`Connected to leader at ${defaultServer}`);\n            resolve({ socket, redirect: false });\n          } else if (info.leaderAddress) {\n            console.log(`Redirecting to leader at ${info.leaderAddress}`);\n            socket.disconnect();\n            resolve({ socket: null, redirect: true, redirectTo: info.leaderAddress });\n          } else {\n            socket.disconnect();\n            reject(new Error('No leader information available'));\n          }\n        });\n        \n        socket.on('connect_error', (err) => {\n          clearTimeout(timeoutId);\n          socket.disconnect();\n          reject(err);\n        });\n      });\n      \n      // If we need to redirect to the leader\n      if (result.redirect) {\n        return io(result.redirectTo);\n      }\n      \n      return result.socket;\n    } catch (defaultServerError) {\n      console.warn('Failed to connect to default server:', defaultServerError);\n      \n      // If we have multiple servers configured, try them in sequence\n      if (config.clusterServers && Array.isArray(config.clusterServers) && config.clusterServers.length > 0) {\n        for (const serverUrl of config.clusterServers) {\n          try {\n            console.log(`Trying to connect to ${serverUrl}`);\n            const socket = io(serverUrl, { timeout: 3000 });\n            \n            // Wait to see if this connection succeeds\n            const result = await new Promise((resolve, reject) => {\n              let timeoutId = setTimeout(() => {\n                socket.disconnect();\n                reject(new Error(`Connection to ${serverUrl} timed out`));\n              }, 3000);\n              \n              socket.on('connect', () => {\n                socket.emit('getLeaderInfo');\n              });\n              \n              socket.on('leaderInfo', (info) => {\n                clearTimeout(timeoutId);\n                if (info.isLeader) {\n                  console.log(`Connected to leader at ${serverUrl}`);\n                  resolve({ socket, redirect: false });\n                } else if (info.leaderAddress) {\n                  console.log(`Redirecting to leader at ${info.leaderAddress}`);\n                  socket.disconnect();\n                  resolve({ socket: null, redirect: true, redirectTo: info.leaderAddress });\n                } else {\n                  socket.disconnect();\n                  reject(new Error('No leader information available'));\n                }\n              });\n              \n              socket.on('connect_error', (err) => {\n                clearTimeout(timeoutId);\n                socket.disconnect();\n                reject(err);\n              });\n            });\n            \n            // If we need to redirect to the leader\n            if (result.redirect) {\n              return io(result.redirectTo);\n            }\n            \n            return result.socket;\n          } catch (error) {\n            console.warn(`Failed to connect to ${serverUrl}:`, error);\n            // Continue trying next server\n          }\n        }\n      }\n      \n      // If all attempts fail, throw an error\n      throw new Error('Could not connect to any server in the cluster');\n    }\n  } catch (error) {\n    console.error('Server discovery failed:', error);\n    throw error;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}