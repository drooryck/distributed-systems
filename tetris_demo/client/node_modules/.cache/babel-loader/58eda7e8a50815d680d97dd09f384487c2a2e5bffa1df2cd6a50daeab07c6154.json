{"ast":null,"code":"import{io}from'socket.io-client';import{EventEmitter}from'events';import{saveGameSession,getGameSession,clearGameSession}from'./sessionStorage';/**\n * ServerConnectionManager\n * - Connects to multiple tetris servers in the cluster\n * - Discovers the leader server\n * - Maintains connection to the leader\n * - Handles automatic failover to a new leader\n * - Forwards game events to the application\n */class ServerConnectionManager extends EventEmitter{constructor(){super();this.connections={};this.serverList=[];this.activeSocket=null;this.leaderServer=null;this.socketId=null;this.hasRejoinedRoom=false;// Debug logging\nthis.debug=true;// Reconnection settings\nthis.reconnectInterval=3000;this.reconnectAttempts=0;this.maxReconnectAttempts=5;// Status tracking\nthis.initialized=false;this.reconnectTimer=null;}log(message){if(this.debug){console.log(`[ServerManager] ${message}`);}}/**\n   * Initialize the server connection manager and connect to servers\n   * @param {function} onConnectedCallback - Called when connected to leader\n   * @param {function} onStateChangeCallback - Called when server state changes\n   * @param {Array} serverList - Optional custom server list\n   */async initialize(){let onConnectedCallback=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let onStateChangeCallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let serverList=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(this.initialized){return;}this.onConnectedCallback=onConnectedCallback;this.onStateChangeCallback=onStateChangeCallback;try{var _config$client;// Load server configuration from config.json\nconst config=await this.loadConfig();// Use provided server list, config, or default to localhost ports\nthis.serverList=serverList||((_config$client=config.client)===null||_config$client===void 0?void 0:_config$client.serverAddresses)||[\"http://localhost:3001\",\"http://localhost:3002\",\"http://localhost:3003\"];this.log(`Initializing with ${this.serverList.length} servers: ${this.serverList.join(', ')}`);// Connect to all servers to find the leader\nconst connectionPromises=this.serverList.map(serverUrl=>this.connectToServer(serverUrl));// Wait for all connection attempts (some may fail, that's expected)\nawait Promise.allSettled(connectionPromises);this.initialized=true;// If we don't have a leader yet, try a specific check\nif(!this.leaderServer){await this.findLeader();}// If still no leader, try the first available server\nif(!this.leaderServer){this.findFirstAvailableServer();}// Set up automatic periodic check for leader changes\nsetInterval(()=>this.verifyLeader(),10000);}catch(error){this.log(`Initialization error: ${error.message}`);throw new Error(`Failed to initialize server connection: ${error.message}`);}}/**\n   * Load configuration from config.json\n   */async loadConfig(){try{const response=await fetch('/config.json');if(!response.ok){throw new Error(`Failed to load config: ${response.status}`);}return await response.json();}catch(error){this.log(`Config load error: ${error.message}. Using defaults.`);return{client:{serverAddresses:[\"http://localhost:3001\",\"http://localhost:3002\",\"http://localhost:3003\"]}};}}/**\n   * Connect to a server by URL\n   * @param {string} serverUrl - The server URL to connect to\n   */async connectToServer(serverUrl){this.log(`Connecting to server at ${serverUrl}`);const serverId=this.serverList.indexOf(serverUrl);// Create connection entry\nconst connection={id:serverId>=0?serverId:Object.keys(this.connections).length,url:serverUrl,socket:null,isConnected:false,isLeader:false,lastActivity:Date.now()};// Connect to the server\nconst socket=io(serverUrl,{reconnection:false,// We handle reconnection manually\ntimeout:5000});return new Promise((resolve,reject)=>{// Set up connection timeout\nconst timeout=setTimeout(()=>{socket.close();reject(new Error(`Connection timeout to ${serverUrl}`));},5000);// Handle connection\nsocket.on('connect',()=>{clearTimeout(timeout);this.log(`Connected to server at ${serverUrl} with ID: ${socket.id}`);connection.socket=socket;connection.isConnected=true;connection.lastActivity=Date.now();this.connections[connection.id]=connection;// Check if this server is the leader\nsocket.emit('checkLeader',{},response=>{connection.isLeader=response.isLeader;// If this is the leader, use it as the active server\nif(response.isLeader){this.log(`Server at ${serverUrl} is the leader (ID: ${response.leaderId})`);this.setActiveLeader(connection);}// If not leader and we're informed about a leader\nelse if(response.leaderAddress){this.log(`Server at ${serverUrl} reports leader at: ${response.leaderAddress}`);// We might connect to that leader in another connection attempt\n}resolve(connection);});});// Handle connection error\nsocket.on('connect_error',error=>{clearTimeout(timeout);this.log(`Connection error to ${serverUrl}: ${error.message}`);reject(error);});// Handle disconnection\nsocket.on('disconnect',reason=>{this.log(`Disconnected from ${serverUrl}: ${reason}`);connection.isConnected=false;// If this was the leader, find a new one\nif(this.leaderServer===connection){this.log(`Leader disconnected, finding new leader...`);this.leaderServer=null;this.activeSocket=null;// Notify about server change\nif(this.onStateChangeCallback){this.onStateChangeCallback({type:'leaderDisconnected',reason});}// Try to find a new leader\nthis.findLeader();}});}).catch(error=>{this.log(`Failed to connect to ${serverUrl}: ${error.message}`);// Don't throw - we just continue with other servers\n});}/**\n   * Find the leader among connected servers\n   */async findLeader(){this.log('Searching for leader server...');const checkLeaderPromises=[];// Ask all connected servers if they're the leader\nfor(const id in this.connections){const connection=this.connections[id];if(connection.isConnected&&connection.socket){const checkPromise=new Promise(resolve=>{connection.socket.emit('checkLeader',{},response=>{if(response){connection.isLeader=response.isLeader;if(response.isLeader){this.log(`Server ${connection.url} confirmed as leader`);this.setActiveLeader(connection);}}resolve();});});checkLeaderPromises.push(checkPromise);}}// Wait for all checks to complete\nawait Promise.all(checkLeaderPromises);return this.leaderServer!==null;}/**\n   * Find and use the first available server if no leader\n   */findFirstAvailableServer(){// If no leader found, try the first connected server\nif(!this.leaderServer){for(const id in this.connections){const connection=this.connections[id];if(connection.isConnected){this.log(`No leader found. Using ${connection.url} as temporary server`);this.setActiveLeader(connection);break;}}}// If still no server available, schedule reconnection attempts\nif(!this.leaderServer){this.scheduleReconnect();}}/**\n   * Schedule reconnection attempts for disconnected servers\n   */scheduleReconnect(){this.reconnectAttempts++;if(this.reconnectAttempts<=this.maxReconnectAttempts){// Clear any existing reconnect timer\nif(this.reconnectTimer){clearTimeout(this.reconnectTimer);}// Exponential backoff for reconnect delay\nconst delay=Math.min(this.reconnectInterval*Math.pow(1.5,this.reconnectAttempts-1),30000);this.log(`Scheduling reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);this.reconnectTimer=setTimeout(async()=>{this.log(`Attempting to reconnect to servers...`);// Try to connect to all servers again\ntry{const connectionPromises=this.serverList.map(serverUrl=>{// Only reconnect if we don't have an active connection\nconst existingConn=Object.values(this.connections).find(c=>c.url===serverUrl&&c.isConnected);if(!existingConn){return this.connectToServer(serverUrl);}return Promise.resolve();});await Promise.allSettled(connectionPromises);// Find leader among new connections\nawait this.findLeader();// If still no leader, try the first available\nif(!this.leaderServer){this.findFirstAvailableServer();}}catch(error){this.log(`Reconnection attempt failed: ${error.message}`);}// If still no leader and not at max attempts, schedule another try\nif(!this.leaderServer&&this.reconnectAttempts<this.maxReconnectAttempts){this.scheduleReconnect();}else if(!this.leaderServer){this.log('Max reconnection attempts reached. No available servers.');// Notify about connection failure\nif(this.onStateChangeCallback){this.onStateChangeCallback({type:'allServersDown'});}}},delay);}else{this.log('Max reconnection attempts reached. No available servers.');// Notify about connection failure\nif(this.onStateChangeCallback){this.onStateChangeCallback({type:'allServersDown'});}}}/**\n   * Set a connection as the active leader\n   * @param {Object} connection - The connection to use as leader\n   */setActiveLeader(connection){const wasLeaderChange=this.leaderServer!==connection;this.leaderServer=connection;this.activeSocket=connection.socket;this.log(`Setting ${connection.url} as active leader`);// Reset reconnect count when we have a leader\nthis.reconnectAttempts=0;// Forward events from this socket\nthis.forwardEvents(connection.socket);// Store the socket ID for reference\nthis.socketId=connection.socket.id;// Call the connected callback if provided\nif(wasLeaderChange&&this.onConnectedCallback){this.onConnectedCallback(this.activeSocket);}// Notify about server change if we switched leaders\nif(wasLeaderChange&&this.onStateChangeCallback){this.onStateChangeCallback({type:'leaderChanged',server:connection});}// Request initial state from new leader\nconnection.socket.emit('requestInitialState');// Try to rejoin a room if we have session data\nthis.attemptRoomRejoin(connection.socket);}/**\n   * Forward events from socket to this event emitter\n   * @param {Object} socket - The socket to forward events from\n   */forwardEvents(socket){if(!socket)return;// List of events to forward from socket to this event emitter\nconst eventsToForward=['init','gameState','roomCreated','roomJoined','roomRejoined','roomLeft','playerJoined','playerLeft','playerRejoined','hostAssigned','gameOver','error'];// Remove any existing listeners to avoid duplicates\nsocket.removeAllListeners();// Set connect/disconnect handlers\nsocket.on('connect',()=>{this.log(`Socket ${socket.id} connected`);this.socketId=socket.id;});socket.on('disconnect',reason=>{this.log(`Socket ${socket.id} disconnected: ${reason}`);this.emit('disconnect',reason);});// Forward all game events from socket to this emitter\neventsToForward.forEach(eventName=>{socket.on(eventName,data=>{this.emit(eventName,data);});});}/**\n   * Attempt to rejoin a game room on reconnection\n   * @param {Object} socket - The socket to use for room rejoining\n   */attemptRoomRejoin(socket){if(!socket||this.hasRejoinedRoom)return;const session=getGameSession();if(!session||!session.roomCode)return;this.log(`Attempting to rejoin room ${session.roomCode}`);// Send rejoin request\nsocket.emit('rejoinRoom',{roomCode:session.roomCode,playerName:session.playerName,previousSocketId:session.socketId});// Listen for successful rejoin\nconst successHandler=data=>{this.log(`Successfully rejoined room ${session.roomCode}`);this.hasRejoinedRoom=true;// Update session with new socket ID\nsaveGameSession({...session,socketId:socket.id});// Remove these temporary listeners\nsocket.off('roomRejoined',successHandler);socket.off('error',errorHandler);};const errorHandler=error=>{this.log(`Failed to rejoin room: ${error.message}`);// Clear the session on error to prevent future failed attempts\nclearGameSession();// Remove temporary listeners\nsocket.off('roomRejoined',successHandler);socket.off('error',errorHandler);};// Add temporary listeners\nsocket.once('roomRejoined',successHandler);socket.once('error',errorHandler);}/**\n   * Verify the current leader is still the leader\n   */verifyLeader(){if(!this.leaderServer||!this.activeSocket)return;// Check the current leader is still active\nif(!this.activeSocket.connected){this.log('Leader socket disconnected, finding new leader');this.leaderServer=null;this.activeSocket=null;this.findLeader();return;}// Verify current server is still the leader\nthis.activeSocket.emit('checkLeader',{},response=>{if(!response)return;if(!response.isLeader&&response.leaderAddress){this.log(`Current server is no longer leader. New leader at ${response.leaderAddress}`);// Try to connect to the new leader if we don't have it already\nconst leaderConn=Object.values(this.connections).find(c=>c.url===response.leaderAddress&&c.isConnected);if(leaderConn){// We already have a connection to the new leader, use it\nthis.setActiveLeader(leaderConn);}else{// Connect to the new leader\nthis.connectToServer(response.leaderAddress).then(newConn=>{if(newConn&&newConn.isLeader){this.setActiveLeader(newConn);}}).catch(error=>{this.log(`Failed to connect to new leader: ${error.message}`);});}}});}/**\n   * Get the active socket for communication with server\n   * @returns {Object} The active socket\n   */getSocket(){return this.activeSocket;}/**\n   * Get the current socket ID\n   * @returns {string} The socket ID\n   */getSocketId(){return this.socketId;}/**\n   * Disconnect from all servers\n   */disconnect(){for(const id in this.connections){const connection=this.connections[id];if(connection.socket){connection.socket.disconnect();}}this.connections={};this.leaderServer=null;this.activeSocket=null;this.initialized=false;if(this.reconnectTimer){clearTimeout(this.reconnectTimer);this.reconnectTimer=null;}}/**\n   * Emit an event to the active server\n   * @param {string} event - The event name\n   * @param {any} data - The data to send\n   */emit(eventName){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}if(eventName==='newListener'||eventName==='removeListener'){// These are EventEmitter events, pass to super\nreturn super.emit(eventName,...args);}if(this.activeSocket){this.activeSocket.emit(eventName,...args);}else{this.log(`Cannot emit ${eventName}: no active socket`);}}/**\n   * Save session data for reconnection\n   * @param {Object} data - Session data to save\n   */saveSessionData(data){saveGameSession(data);}/**\n   * Clear session data\n   */clearSessionData(){clearGameSession();}}// Export singleton instance\nconst serverManager=new ServerConnectionManager();export default serverManager;","map":{"version":3,"names":["io","EventEmitter","saveGameSession","getGameSession","clearGameSession","ServerConnectionManager","constructor","connections","serverList","activeSocket","leaderServer","socketId","hasRejoinedRoom","debug","reconnectInterval","reconnectAttempts","maxReconnectAttempts","initialized","reconnectTimer","log","message","console","initialize","onConnectedCallback","arguments","length","undefined","onStateChangeCallback","_config$client","config","loadConfig","client","serverAddresses","join","connectionPromises","map","serverUrl","connectToServer","Promise","allSettled","findLeader","findFirstAvailableServer","setInterval","verifyLeader","error","Error","response","fetch","ok","status","json","serverId","indexOf","connection","id","Object","keys","url","socket","isConnected","isLeader","lastActivity","Date","now","reconnection","timeout","resolve","reject","setTimeout","close","on","clearTimeout","emit","leaderId","setActiveLeader","leaderAddress","reason","type","catch","checkLeaderPromises","checkPromise","push","all","scheduleReconnect","delay","Math","min","pow","existingConn","values","find","c","wasLeaderChange","forwardEvents","server","attemptRoomRejoin","eventsToForward","removeAllListeners","forEach","eventName","data","session","roomCode","playerName","previousSocketId","successHandler","off","errorHandler","once","connected","leaderConn","then","newConn","getSocket","getSocketId","disconnect","_len","args","Array","_key","saveSessionData","clearSessionData","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\n/**\n * ServerConnectionManager\n * - Connects to multiple tetris servers in the cluster\n * - Discovers the leader server\n * - Maintains connection to the leader\n * - Handles automatic failover to a new leader\n * - Forwards game events to the application\n */\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.connections = {};\n    this.serverList = [];\n    this.activeSocket = null;\n    this.leaderServer = null;\n    this.socketId = null;\n    this.hasRejoinedRoom = false;\n    \n    // Debug logging\n    this.debug = true;\n    \n    // Reconnection settings\n    this.reconnectInterval = 3000;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    \n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  \n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  \n  /**\n   * Initialize the server connection manager and connect to servers\n   * @param {function} onConnectedCallback - Called when connected to leader\n   * @param {function} onStateChangeCallback - Called when server state changes\n   * @param {Array} serverList - Optional custom server list\n   */\n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    \n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n    \n    try {\n      // Load server configuration from config.json\n      const config = await this.loadConfig();\n      \n      // Use provided server list, config, or default to localhost ports\n      this.serverList = serverList || config.client?.serverAddresses || [\n        \"http://localhost:3001\",\n        \"http://localhost:3002\", \n        \"http://localhost:3003\"\n      ];\n      \n      this.log(`Initializing with ${this.serverList.length} servers: ${this.serverList.join(', ')}`);\n      \n      // Connect to all servers to find the leader\n      const connectionPromises = this.serverList.map(serverUrl => this.connectToServer(serverUrl));\n      \n      // Wait for all connection attempts (some may fail, that's expected)\n      await Promise.allSettled(connectionPromises);\n      \n      this.initialized = true;\n      \n      // If we don't have a leader yet, try a specific check\n      if (!this.leaderServer) {\n        await this.findLeader();\n      }\n      \n      // If still no leader, try the first available server\n      if (!this.leaderServer) {\n        this.findFirstAvailableServer();\n      }\n      \n      // Set up automatic periodic check for leader changes\n      setInterval(() => this.verifyLeader(), 10000);\n      \n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      throw new Error(`Failed to initialize server connection: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Load configuration from config.json\n   */\n  async loadConfig() {\n    try {\n      const response = await fetch('/config.json');\n      if (!response.ok) {\n        throw new Error(`Failed to load config: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      this.log(`Config load error: ${error.message}. Using defaults.`);\n      return { client: { serverAddresses: [\"http://localhost:3001\", \"http://localhost:3002\", \"http://localhost:3003\"] } };\n    }\n  }\n  \n  /**\n   * Connect to a server by URL\n   * @param {string} serverUrl - The server URL to connect to\n   */\n  async connectToServer(serverUrl) {\n    this.log(`Connecting to server at ${serverUrl}`);\n    \n    const serverId = this.serverList.indexOf(serverUrl);\n    \n    // Create connection entry\n    const connection = {\n      id: serverId >= 0 ? serverId : Object.keys(this.connections).length,\n      url: serverUrl,\n      socket: null,\n      isConnected: false,\n      isLeader: false,\n      lastActivity: Date.now()\n    };\n    \n    // Connect to the server\n    const socket = io(serverUrl, {\n      reconnection: false, // We handle reconnection manually\n      timeout: 5000\n    });\n    \n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error(`Connection timeout to ${serverUrl}`));\n      }, 5000);\n      \n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server at ${serverUrl} with ID: ${socket.id}`);\n        \n        connection.socket = socket;\n        connection.isConnected = true;\n        connection.lastActivity = Date.now();\n        \n        this.connections[connection.id] = connection;\n        \n        // Check if this server is the leader\n        socket.emit('checkLeader', {}, (response) => {\n          connection.isLeader = response.isLeader;\n          \n          // If this is the leader, use it as the active server\n          if (response.isLeader) {\n            this.log(`Server at ${serverUrl} is the leader (ID: ${response.leaderId})`);\n            this.setActiveLeader(connection);\n          }\n          // If not leader and we're informed about a leader\n          else if (response.leaderAddress) {\n            this.log(`Server at ${serverUrl} reports leader at: ${response.leaderAddress}`);\n            // We might connect to that leader in another connection attempt\n          }\n          \n          resolve(connection);\n        });\n      });\n      \n      // Handle connection error\n      socket.on('connect_error', (error) => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${serverUrl}: ${error.message}`);\n        reject(error);\n      });\n      \n      // Handle disconnection\n      socket.on('disconnect', (reason) => {\n        this.log(`Disconnected from ${serverUrl}: ${reason}`);\n        connection.isConnected = false;\n        \n        // If this was the leader, find a new one\n        if (this.leaderServer === connection) {\n          this.log(`Leader disconnected, finding new leader...`);\n          this.leaderServer = null;\n          this.activeSocket = null;\n          \n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'leaderDisconnected',\n              reason\n            });\n          }\n          \n          // Try to find a new leader\n          this.findLeader();\n        }\n      });\n    }).catch(error => {\n      this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n      // Don't throw - we just continue with other servers\n    });\n  }\n  \n  /**\n   * Find the leader among connected servers\n   */\n  async findLeader() {\n    this.log('Searching for leader server...');\n    \n    const checkLeaderPromises = [];\n    \n    // Ask all connected servers if they're the leader\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.isConnected && connection.socket) {\n        const checkPromise = new Promise(resolve => {\n          connection.socket.emit('checkLeader', {}, (response) => {\n            if (response) {\n              connection.isLeader = response.isLeader;\n              if (response.isLeader) {\n                this.log(`Server ${connection.url} confirmed as leader`);\n                this.setActiveLeader(connection);\n              }\n            }\n            resolve();\n          });\n        });\n        \n        checkLeaderPromises.push(checkPromise);\n      }\n    }\n    \n    // Wait for all checks to complete\n    await Promise.all(checkLeaderPromises);\n    \n    return this.leaderServer !== null;\n  }\n  \n  /**\n   * Find and use the first available server if no leader\n   */\n  findFirstAvailableServer() {\n    // If no leader found, try the first connected server\n    if (!this.leaderServer) {\n      for (const id in this.connections) {\n        const connection = this.connections[id];\n        if (connection.isConnected) {\n          this.log(`No leader found. Using ${connection.url} as temporary server`);\n          this.setActiveLeader(connection);\n          break;\n        }\n      }\n    }\n    \n    // If still no server available, schedule reconnection attempts\n    if (!this.leaderServer) {\n      this.scheduleReconnect();\n    }\n  }\n  \n  /**\n   * Schedule reconnection attempts for disconnected servers\n   */\n  scheduleReconnect() {\n    this.reconnectAttempts++;\n    \n    if (this.reconnectAttempts <= this.maxReconnectAttempts) {\n      // Clear any existing reconnect timer\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n      \n      // Exponential backoff for reconnect delay\n      const delay = Math.min(this.reconnectInterval * Math.pow(1.5, this.reconnectAttempts - 1), 30000);\n      \n      this.log(`Scheduling reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);\n      \n      this.reconnectTimer = setTimeout(async () => {\n        this.log(`Attempting to reconnect to servers...`);\n        \n        // Try to connect to all servers again\n        try {\n          const connectionPromises = this.serverList.map(serverUrl => {\n            // Only reconnect if we don't have an active connection\n            const existingConn = Object.values(this.connections).find(c => c.url === serverUrl && c.isConnected);\n            if (!existingConn) {\n              return this.connectToServer(serverUrl);\n            }\n            return Promise.resolve();\n          });\n          \n          await Promise.allSettled(connectionPromises);\n          \n          // Find leader among new connections\n          await this.findLeader();\n          \n          // If still no leader, try the first available\n          if (!this.leaderServer) {\n            this.findFirstAvailableServer();\n          }\n          \n        } catch (error) {\n          this.log(`Reconnection attempt failed: ${error.message}`);\n        }\n        \n        // If still no leader and not at max attempts, schedule another try\n        if (!this.leaderServer && this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.scheduleReconnect();\n        } else if (!this.leaderServer) {\n          this.log('Max reconnection attempts reached. No available servers.');\n          // Notify about connection failure\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'allServersDown'\n            });\n          }\n        }\n      }, delay);\n    } else {\n      this.log('Max reconnection attempts reached. No available servers.');\n      // Notify about connection failure\n      if (this.onStateChangeCallback) {\n        this.onStateChangeCallback({\n          type: 'allServersDown'\n        });\n      }\n    }\n  }\n  \n  /**\n   * Set a connection as the active leader\n   * @param {Object} connection - The connection to use as leader\n   */\n  setActiveLeader(connection) {\n    const wasLeaderChange = this.leaderServer !== connection;\n    this.leaderServer = connection;\n    this.activeSocket = connection.socket;\n    \n    this.log(`Setting ${connection.url} as active leader`);\n    \n    // Reset reconnect count when we have a leader\n    this.reconnectAttempts = 0;\n    \n    // Forward events from this socket\n    this.forwardEvents(connection.socket);\n    \n    // Store the socket ID for reference\n    this.socketId = connection.socket.id;\n    \n    // Call the connected callback if provided\n    if (wasLeaderChange && this.onConnectedCallback) {\n      this.onConnectedCallback(this.activeSocket);\n    }\n    \n    // Notify about server change if we switched leaders\n    if (wasLeaderChange && this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'leaderChanged',\n        server: connection\n      });\n    }\n    \n    // Request initial state from new leader\n    connection.socket.emit('requestInitialState');\n    \n    // Try to rejoin a room if we have session data\n    this.attemptRoomRejoin(connection.socket);\n  }\n  \n  /**\n   * Forward events from socket to this event emitter\n   * @param {Object} socket - The socket to forward events from\n   */\n  forwardEvents(socket) {\n    if (!socket) return;\n    \n    // List of events to forward from socket to this event emitter\n    const eventsToForward = [\n      'init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined',\n      'roomLeft', 'playerJoined', 'playerLeft', 'playerRejoined',\n      'hostAssigned', 'gameOver', 'error'\n    ];\n    \n    // Remove any existing listeners to avoid duplicates\n    socket.removeAllListeners();\n    \n    // Set connect/disconnect handlers\n    socket.on('connect', () => {\n      this.log(`Socket ${socket.id} connected`);\n      this.socketId = socket.id; \n    });\n    \n    socket.on('disconnect', (reason) => {\n      this.log(`Socket ${socket.id} disconnected: ${reason}`);\n      this.emit('disconnect', reason);\n    });\n    \n    // Forward all game events from socket to this emitter\n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, (data) => {\n        this.emit(eventName, data);\n      });\n    });\n  }\n  \n  /**\n   * Attempt to rejoin a game room on reconnection\n   * @param {Object} socket - The socket to use for room rejoining\n   */\n  attemptRoomRejoin(socket) {\n    if (!socket || this.hasRejoinedRoom) return;\n    \n    const session = getGameSession();\n    if (!session || !session.roomCode) return;\n    \n    this.log(`Attempting to rejoin room ${session.roomCode}`);\n    \n    // Send rejoin request\n    socket.emit('rejoinRoom', {\n      roomCode: session.roomCode,\n      playerName: session.playerName,\n      previousSocketId: session.socketId\n    });\n    \n    // Listen for successful rejoin\n    const successHandler = (data) => {\n      this.log(`Successfully rejoined room ${session.roomCode}`);\n      this.hasRejoinedRoom = true;\n      \n      // Update session with new socket ID\n      saveGameSession({\n        ...session,\n        socketId: socket.id\n      });\n      \n      // Remove these temporary listeners\n      socket.off('roomRejoined', successHandler);\n      socket.off('error', errorHandler);\n    };\n    \n    const errorHandler = (error) => {\n      this.log(`Failed to rejoin room: ${error.message}`);\n      // Clear the session on error to prevent future failed attempts\n      clearGameSession();\n      \n      // Remove temporary listeners\n      socket.off('roomRejoined', successHandler);\n      socket.off('error', errorHandler);\n    };\n    \n    // Add temporary listeners\n    socket.once('roomRejoined', successHandler);\n    socket.once('error', errorHandler);\n  }\n  \n  /**\n   * Verify the current leader is still the leader\n   */\n  verifyLeader() {\n    if (!this.leaderServer || !this.activeSocket) return;\n    \n    // Check the current leader is still active\n    if (!this.activeSocket.connected) {\n      this.log('Leader socket disconnected, finding new leader');\n      this.leaderServer = null;\n      this.activeSocket = null;\n      this.findLeader();\n      return;\n    }\n    \n    // Verify current server is still the leader\n    this.activeSocket.emit('checkLeader', {}, (response) => {\n      if (!response) return;\n      \n      if (!response.isLeader && response.leaderAddress) {\n        this.log(`Current server is no longer leader. New leader at ${response.leaderAddress}`);\n        \n        // Try to connect to the new leader if we don't have it already\n        const leaderConn = Object.values(this.connections).find(c => \n          c.url === response.leaderAddress && c.isConnected);\n          \n        if (leaderConn) {\n          // We already have a connection to the new leader, use it\n          this.setActiveLeader(leaderConn);\n        } else {\n          // Connect to the new leader\n          this.connectToServer(response.leaderAddress)\n            .then(newConn => {\n              if (newConn && newConn.isLeader) {\n                this.setActiveLeader(newConn);\n              }\n            })\n            .catch(error => {\n              this.log(`Failed to connect to new leader: ${error.message}`);\n            });\n        }\n      }\n    });\n  }\n  \n  /**\n   * Get the active socket for communication with server\n   * @returns {Object} The active socket\n   */\n  getSocket() {\n    return this.activeSocket;\n  }\n  \n  /**\n   * Get the current socket ID\n   * @returns {string} The socket ID\n   */\n  getSocketId() {\n    return this.socketId;\n  }\n  \n  /**\n   * Disconnect from all servers\n   */\n  disconnect() {\n    for (const id in this.connections) {\n      const connection = this.connections[id];\n      if (connection.socket) {\n        connection.socket.disconnect();\n      }\n    }\n    \n    this.connections = {};\n    this.leaderServer = null;\n    this.activeSocket = null;\n    this.initialized = false;\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n  \n  /**\n   * Emit an event to the active server\n   * @param {string} event - The event name\n   * @param {any} data - The data to send\n   */\n  emit(eventName, ...args) {\n    if (eventName === 'newListener' || eventName === 'removeListener') {\n      // These are EventEmitter events, pass to super\n      return super.emit(eventName, ...args);\n    }\n    \n    if (this.activeSocket) {\n      this.activeSocket.emit(eventName, ...args);\n    } else {\n      this.log(`Cannot emit ${eventName}: no active socket`);\n    }\n  }\n  \n  /**\n   * Save session data for reconnection\n   * @param {Object} data - Session data to save\n   */\n  saveSessionData(data) {\n    saveGameSession(data);\n  }\n  \n  /**\n   * Clear session data\n   */\n  clearSessionData() {\n    clearGameSession();\n  }\n}\n\n// Export singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}