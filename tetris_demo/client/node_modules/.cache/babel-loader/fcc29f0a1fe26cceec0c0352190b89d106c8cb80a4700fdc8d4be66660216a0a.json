{"ast":null,"code":"import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\n// Add this function to load the config at the top of your file\nasync function loadConfig() {\n  try {\n    // Get the current hostname - this lets it work from any address\n    const currentUrl = new URL(window.location.href);\n    const configPath = `${currentUrl.protocol}//${currentUrl.host}/config.json`;\n    console.log(`Loading config from ${configPath}`);\n    const response = await fetch(configPath);\n    if (!response.ok) {\n      console.warn(`Failed to load config.json: ${response.status}`);\n      return null;\n    }\n    const config = await response.json();\n    console.log('Successfully loaded config:', config);\n    return config;\n  } catch (error) {\n    console.warn('Error loading config.json:', error);\n    return null;\n  }\n}\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.serverList = [];\n    this.activeSocket = null;\n    this.socketId = null;\n\n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n\n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n\n    // Try to load server list from config.json first\n    let configServers = null;\n    try {\n      const config = await loadConfig();\n      if (config && config.client && Array.isArray(config.client.serverAddresses)) {\n        configServers = config.client.serverAddresses;\n        this.log(`Loaded ${configServers.length} servers from config.json`);\n        // log the whole addresses\n\n        // configServers.forEach((server, index) => {\n        //   this.log(`Server ${index}: ${JSON.stringify(server)}`);\n        // });\n      }\n    } catch (e) {\n      this.log(`Error loading config: ${e.message}`);\n    }\n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = configServers || [{\n        id: 0,\n        host: 'localhost',\n        port: 3001\n      }, {\n        id: 1,\n        host: 'localhost',\n        port: 3002\n      }, {\n        id: 2,\n        host: 'localhost',\n        port: 3003\n      }];\n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n      // log the whole server list\n      this.serverList.forEach((server, index) => {\n        this.log(`Server ${index}: ${JSON.stringify(server)}`);\n      });\n\n      // First try to connect to any server to find the leader\n      let leaderServer = null;\n      for (const server of this.serverList) {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        try {\n          this.log(`Checking server ${serverUrl} for leader info`);\n          const socket = io(serverUrl, {\n            reconnection: false,\n            timeout: 5000\n          });\n\n          // Wait for connection or timeout\n          const isConnected = await new Promise(resolve => {\n            const timeout = setTimeout(() => {\n              socket.disconnect();\n              resolve(false);\n            }, 5000);\n            socket.on('connect', () => {\n              clearTimeout(timeout);\n              resolve(true);\n            });\n            socket.on('connect_error', () => {\n              clearTimeout(timeout);\n              socket.disconnect();\n              resolve(false);\n            });\n          });\n          if (isConnected) {\n            // Get leader info from this server\n            const leaderInfo = await new Promise(resolve => {\n              socket.emit('checkLeader', {}, response => {\n                if (response && response.isLeader) {\n                  // This server is the leader\n                  resolve({\n                    id: server.id,\n                    host: server.host,\n                    port: server.port,\n                    url: serverUrl\n                  });\n                } else if (response && response.leaderUrl) {\n                  // Get leader info from response\n                  const leaderParts = response.leaderUrl.split(':');\n                  const leaderPort = parseInt(leaderParts[leaderParts.length - 1]);\n                  const leaderHost = leaderParts[leaderParts.length - 2].replace(/\\/\\//g, '');\n                  resolve({\n                    id: response.leaderId || 0,\n                    host: leaderHost,\n                    port: leaderPort,\n                    url: response.leaderUrl\n                  });\n                } else {\n                  // No leader info, use this server temporarily\n                  resolve({\n                    id: server.id,\n                    host: server.host,\n                    port: server.port,\n                    url: serverUrl\n                  });\n                }\n              });\n\n              // If no response in 3 seconds, just use this server\n              setTimeout(() => {\n                resolve({\n                  id: server.id,\n                  host: server.host,\n                  port: server.port,\n                  url: serverUrl\n                });\n              }, 3000);\n            });\n            socket.disconnect();\n            leaderServer = leaderInfo;\n            break;\n          }\n        } catch (error) {\n          this.log(`Error checking server ${serverUrl}: ${error.message}`);\n          // Continue to next server\n        }\n      }\n\n      // Now connect to the leader server or first server if no leader found\n      if (leaderServer) {\n        this.log(`Connecting to leader server at ${leaderServer.url}`);\n        await this.connectToServer(leaderServer);\n      } else if (this.serverList.length > 0) {\n        // Try each server until one works\n        for (const server of this.serverList) {\n          const serverUrl = `http://${server.host}:${server.port}`;\n          try {\n            this.log(`Trying to connect to server ${serverUrl}`);\n            await this.connectToServer({\n              id: server.id,\n              host: server.host,\n              port: server.port,\n              url: serverUrl\n            });\n            if (this.activeSocket) break;\n          } catch (error) {\n            this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n          }\n        }\n      }\n      this.initialized = true;\n\n      // If we don't have a connection yet, schedule a retry\n      if (!this.activeSocket && this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      if (this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    }\n  }\n  async connectToServer(server) {\n    if (!server || !server.url) {\n      throw new Error('Invalid server configuration');\n    }\n    const serverUrl = new URL(server.url);\n    const absoluteUrl = `http://${serverUrl.hostname}:${serverUrl.port}`;\n    this.log(`Connecting to server at ${absoluteUrl}`);\n\n    // Connect using the absolute URL (not relative)\n    const socket = io(absoluteUrl, {\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n      timeout: 10000,\n      transports: ['polling', 'websocket'] // Try polling first, then websocket\n    });\n    return new Promise((resolve, reject) => {\n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.disconnect();\n        reject(new Error(`Connection timeout to ${server.url}`));\n      }, 10000);\n\n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server at ${server.url}`);\n        this.setActiveServer(socket, server);\n        resolve(true);\n      });\n\n      // Handle connection error\n      socket.on('connect_error', error => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${server.url}: ${error.message}`);\n        reject(error);\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', reason => {\n        this.log(`Disconnected from ${server.url}: ${reason}`);\n\n        // If this was our active socket, try to reconnect\n        if (this.activeSocket === socket) {\n          this.activeSocket = null;\n\n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'disconnected',\n              message: `Disconnected from server: ${reason}`\n            });\n          }\n          if (this.autoReconnect && reason !== 'io client disconnect') {\n            this.scheduleReconnect();\n          }\n        }\n      });\n    });\n  }\n  setActiveServer(socket, server) {\n    this.activeSocket = socket;\n    this.socketId = socket.id;\n\n    // Forward events from this socket\n    this.forwardEvents(socket);\n\n    // Try to rejoin a room if we have saved session\n    this.attemptRoomRejoin(socket);\n\n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(socket);\n    }\n\n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'connected',\n        server: server.url\n      });\n    }\n  }\n  scheduleReconnect() {\n    // First check if our origin server is different from active leader\n    const currentUrl = new URL(window.location.href);\n    const currentPort = currentUrl.port;\n\n    // Try to find a working server to redirect to\n    this.serverList.forEach(server => {\n      if (server.port.toString() !== currentPort) {\n        // Try a basic ping to see if this server is alive\n        fetch(`http://${server.host}:${server.port}/status`, {\n          timeout: 2000\n        }).then(response => {\n          if (response.ok) {\n            // Found a working server, redirect the browser\n            this.log(`Redirecting to working server: ${server.port}`);\n\n            // Save that we need to rejoin\n            localStorage.setItem('needs_browser_rejoin', 'true');\n\n            // Redirect the browser to the new server\n            window.location.href = window.location.href.replace(`:${currentPort}`, `:${server.port}`);\n            return;\n          }\n        }).catch(() => {\n          // This server is also down, try the next one\n        });\n      }\n    });\n\n    // Continue with normal reconnection if we didn't redirect\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    this.reconnectTimer = setTimeout(async () => {\n      this.log('Attempting to reconnect...');\n      await this.initialize(this.onConnectedCallback, this.onStateChangeCallback);\n    }, this.reconnectInterval);\n  }\n  forwardEvents(socket) {\n    if (!socket) return;\n\n    // Forward common events from the socket to this event emitter\n    const eventsToForward = ['init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined', 'roomLeft', 'playerJoined', 'playerLeft', 'playerReady', 'gameStarted', 'gameOver', 'error', 'disconnect'];\n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, data => {\n        if (eventName === 'init' && typeof data === 'string') {\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = {\n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        this.emit(eventName, data);\n      });\n    });\n  }\n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n\n      // Check if player was ready before disconnection\n      // This is determined by looking at the readyPlayers array in localStorage if available\n      let wasReady = false;\n      try {\n        // Try to determine if player was ready by checking local storage\n        const localReadyStatus = localStorage.getItem(`player_ready_${session.socketId}`);\n        if (localReadyStatus === 'true') {\n          wasReady = true;\n          this.log(`Player was previously ready, sending ready status in rejoin`);\n        }\n      } catch (e) {\n        this.log(`Could not determine previous ready status: ${e.message}`);\n      }\n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId || this.socketId,\n        wasReady: wasReady // Include ready status in rejoin request\n      });\n    }\n  }\n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n\n    // Always forward all events to local listeners\n    return super.emit(eventName, data);\n  }\n  getSocket() {\n    return this.activeSocket;\n  }\n  getSocketId() {\n    return this.socketId;\n  }\n  disconnect() {\n    if (this.activeSocket) {\n      this.activeSocket.disconnect();\n    }\n    this.activeSocket = null;\n    this.initialized = false;\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;","map":{"version":3,"names":["io","EventEmitter","saveGameSession","getGameSession","clearGameSession","loadConfig","currentUrl","URL","window","location","href","configPath","protocol","host","console","log","response","fetch","ok","warn","status","config","json","error","ServerConnectionManager","constructor","serverList","activeSocket","socketId","debug","autoReconnect","reconnectInterval","initialized","reconnectTimer","message","initialize","onConnectedCallback","onStateChangeCallback","configServers","client","Array","isArray","serverAddresses","length","e","id","port","forEach","server","index","JSON","stringify","leaderServer","serverUrl","socket","reconnection","timeout","isConnected","Promise","resolve","setTimeout","disconnect","on","clearTimeout","leaderInfo","emit","isLeader","url","leaderUrl","leaderParts","split","leaderPort","parseInt","leaderHost","replace","leaderId","connectToServer","scheduleReconnect","Error","absoluteUrl","hostname","reconnectionAttempts","reconnectionDelay","reconnectionDelayMax","transports","reject","setActiveServer","reason","type","forwardEvents","attemptRoomRejoin","currentPort","toString","then","localStorage","setItem","catch","eventsToForward","eventName","data","parsedData","parse","appPhase","players","activePlayers","readyPlayers","gameInProgress","session","roomCode","playerName","wasReady","localReadyStatus","getItem","previousSocketId","getSocket","getSocketId","serverManager"],"sources":["/Users/driesrooryck/Desktop/s25/new_try/distributed-systems/tetris/client/src/utils/serverConnection.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport { EventEmitter } from 'events';\nimport { saveGameSession, getGameSession, clearGameSession } from './sessionStorage';\n\n// Add this function to load the config at the top of your file\nasync function loadConfig() {\n  try {\n    // Get the current hostname - this lets it work from any address\n    const currentUrl = new URL(window.location.href);\n    const configPath = `${currentUrl.protocol}//${currentUrl.host}/config.json`;\n    \n    console.log(`Loading config from ${configPath}`);\n    const response = await fetch(configPath);\n    \n    if (!response.ok) {\n      console.warn(`Failed to load config.json: ${response.status}`);\n      return null;\n    }\n    \n    const config = await response.json();\n    console.log('Successfully loaded config:', config);\n    return config;\n  } catch (error) {\n    console.warn('Error loading config.json:', error);\n    return null;\n  }\n}\n\nclass ServerConnectionManager extends EventEmitter {\n  constructor() {\n    super();\n    this.serverList = [];\n    this.activeSocket = null;\n    this.socketId = null;\n    \n    // Configuration\n    this.debug = true;\n    this.autoReconnect = true;\n    this.reconnectInterval = 2000;\n    \n    // Status tracking\n    this.initialized = false;\n    this.reconnectTimer = null;\n  }\n  \n  log(message) {\n    if (this.debug) {\n      console.log(`[ServerManager] ${message}`);\n    }\n  }\n  \n  async initialize(onConnectedCallback = null, onStateChangeCallback = null, serverList = null) {\n    if (this.initialized) {\n      return;\n    }\n    \n    this.onConnectedCallback = onConnectedCallback;\n    this.onStateChangeCallback = onStateChangeCallback;\n\n\n    // Try to load server list from config.json first\n    let configServers = null;\n    try {\n      const config = await loadConfig();\n      if (config && config.client && Array.isArray(config.client.serverAddresses)) {\n        configServers = config.client.serverAddresses;\n\n        this.log(`Loaded ${configServers.length} servers from config.json`);\n        // log the whole addresses\n\n        // configServers.forEach((server, index) => {\n        //   this.log(`Server ${index}: ${JSON.stringify(server)}`);\n        // });\n\n      }\n    } catch (e) {\n      this.log(`Error loading config: ${e.message}`);\n    }\n  \n    try {\n      // Use provided server list or default to localhost ports\n      this.serverList = configServers || [\n        { id: 0, host: 'localhost', port: 3001 },\n        { id: 1, host: 'localhost', port: 3002 }, \n        { id: 2, host: 'localhost', port: 3003 }\n      ];\n      \n      this.log(`Initializing connection manager with ${this.serverList.length} servers`);\n      // log the whole server list\n      this.serverList.forEach((server, index) => {\n        this.log(`Server ${index}: ${JSON.stringify(server)}`);\n      });\n      \n      // First try to connect to any server to find the leader\n      let leaderServer = null;\n      \n      for (const server of this.serverList) {\n        const serverUrl = `http://${server.host}:${server.port}`;\n        try {\n          this.log(`Checking server ${serverUrl} for leader info`);\n          const socket = io(serverUrl, {\n            reconnection: false,\n            timeout: 5000\n          });\n          \n          // Wait for connection or timeout\n          const isConnected = await new Promise((resolve) => {\n            const timeout = setTimeout(() => {\n              socket.disconnect();\n              resolve(false);\n            }, 5000);\n            \n            socket.on('connect', () => {\n              clearTimeout(timeout);\n              resolve(true);\n            });\n            \n            socket.on('connect_error', () => {\n              clearTimeout(timeout);\n              socket.disconnect();\n              resolve(false);\n            });\n          });\n          \n          if (isConnected) {\n            // Get leader info from this server\n            const leaderInfo = await new Promise((resolve) => {\n              socket.emit('checkLeader', {}, (response) => {\n                if (response && response.isLeader) {\n                  // This server is the leader\n                  resolve({\n                    id: server.id,\n                    host: server.host,\n                    port: server.port,\n                    url: serverUrl\n                  });\n                } else if (response && response.leaderUrl) {\n                  // Get leader info from response\n                  const leaderParts = response.leaderUrl.split(':');\n                  const leaderPort = parseInt(leaderParts[leaderParts.length - 1]);\n                  const leaderHost = leaderParts[leaderParts.length - 2].replace(/\\/\\//g, '');\n                  \n                  resolve({\n                    id: response.leaderId || 0,\n                    host: leaderHost,\n                    port: leaderPort,\n                    url: response.leaderUrl\n                  });\n                } else {\n                  // No leader info, use this server temporarily\n                  resolve({\n                    id: server.id,\n                    host: server.host,\n                    port: server.port,\n                    url: serverUrl\n                  });\n                }\n              });\n              \n              // If no response in 3 seconds, just use this server\n              setTimeout(() => {\n                resolve({\n                  id: server.id,\n                  host: server.host,\n                  port: server.port,\n                  url: serverUrl\n                });\n              }, 3000);\n            });\n            \n            socket.disconnect();\n            leaderServer = leaderInfo;\n            break;\n          }\n        } catch (error) {\n          this.log(`Error checking server ${serverUrl}: ${error.message}`);\n          // Continue to next server\n        }\n      }\n      \n      // Now connect to the leader server or first server if no leader found\n      if (leaderServer) {\n        this.log(`Connecting to leader server at ${leaderServer.url}`);\n        await this.connectToServer(leaderServer);\n      } else if (this.serverList.length > 0) {\n        // Try each server until one works\n        for (const server of this.serverList) {\n          const serverUrl = `http://${server.host}:${server.port}`;\n          try {\n            this.log(`Trying to connect to server ${serverUrl}`);\n            await this.connectToServer({ \n              id: server.id,\n              host: server.host,\n              port: server.port,\n              url: serverUrl\n            });\n            if (this.activeSocket) break;\n          } catch (error) {\n            this.log(`Failed to connect to ${serverUrl}: ${error.message}`);\n          }\n        }\n      }\n      \n      this.initialized = true;\n      \n      // If we don't have a connection yet, schedule a retry\n      if (!this.activeSocket && this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    } catch (error) {\n      this.log(`Initialization error: ${error.message}`);\n      if (this.autoReconnect) {\n        this.scheduleReconnect();\n      }\n    }\n  }\n  \n  async connectToServer(server) {\n    if (!server || !server.url) {\n      throw new Error('Invalid server configuration');\n    }\n    \n    const serverUrl = new URL(server.url);\n    const absoluteUrl = `http://${serverUrl.hostname}:${serverUrl.port}`;\n    \n    this.log(`Connecting to server at ${absoluteUrl}`);\n    \n    // Connect using the absolute URL (not relative)\n    const socket = io(absoluteUrl, {\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n      timeout: 10000,\n      transports: ['polling', 'websocket'] // Try polling first, then websocket\n    });\n    \n    return new Promise((resolve, reject) => {\n      \n      // Set up connection timeout\n      const timeout = setTimeout(() => {\n        socket.disconnect();\n        reject(new Error(`Connection timeout to ${server.url}`));\n      }, 10000);\n      \n      // Handle connection\n      socket.on('connect', () => {\n        clearTimeout(timeout);\n        this.log(`Connected to server at ${server.url}`);\n        this.setActiveServer(socket, server);\n        resolve(true);\n      });\n      \n      // Handle connection error\n      socket.on('connect_error', (error) => {\n        clearTimeout(timeout);\n        this.log(`Connection error to ${server.url}: ${error.message}`);\n        reject(error);\n      });\n      \n      // Handle disconnection\n      socket.on('disconnect', (reason) => {\n        this.log(`Disconnected from ${server.url}: ${reason}`);\n        \n        // If this was our active socket, try to reconnect\n        if (this.activeSocket === socket) {\n          this.activeSocket = null;\n          \n          // Notify about server change\n          if (this.onStateChangeCallback) {\n            this.onStateChangeCallback({\n              type: 'disconnected',\n              message: `Disconnected from server: ${reason}`\n            });\n          }\n          \n          if (this.autoReconnect && reason !== 'io client disconnect') {\n            this.scheduleReconnect();\n          }\n        }\n      });\n    });\n  }\n  \n  setActiveServer(socket, server) {\n    this.activeSocket = socket;\n    this.socketId = socket.id;\n    \n    // Forward events from this socket\n    this.forwardEvents(socket);\n    \n    // Try to rejoin a room if we have saved session\n    this.attemptRoomRejoin(socket);\n    \n    // Call the connected callback if provided\n    if (this.onConnectedCallback) {\n      this.onConnectedCallback(socket);\n    }\n    \n    // Notify about server change\n    if (this.onStateChangeCallback) {\n      this.onStateChangeCallback({\n        type: 'connected',\n        server: server.url,\n      });\n    }\n  }\n  \n  scheduleReconnect() {\n    // First check if our origin server is different from active leader\n    const currentUrl = new URL(window.location.href);\n    const currentPort = currentUrl.port;\n    \n    // Try to find a working server to redirect to\n    this.serverList.forEach(server => {\n      if (server.port.toString() !== currentPort) {\n        // Try a basic ping to see if this server is alive\n        fetch(`http://${server.host}:${server.port}/status`, { timeout: 2000 })\n          .then(response => {\n            if (response.ok) {\n              // Found a working server, redirect the browser\n              this.log(`Redirecting to working server: ${server.port}`);\n              \n              // Save that we need to rejoin\n              localStorage.setItem('needs_browser_rejoin', 'true');\n              \n              // Redirect the browser to the new server\n              window.location.href = window.location.href.replace(\n                `:${currentPort}`,\n                `:${server.port}`\n              );\n              return;\n            }\n          })\n          .catch(() => {\n            // This server is also down, try the next one\n          });\n      }\n    });\n    \n    // Continue with normal reconnection if we didn't redirect\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    \n    this.reconnectTimer = setTimeout(async () => {\n      this.log('Attempting to reconnect...');\n      await this.initialize(this.onConnectedCallback, this.onStateChangeCallback);\n    }, this.reconnectInterval);\n  }\n  \n  forwardEvents(socket) {\n    if (!socket) return;\n    \n    // Forward common events from the socket to this event emitter\n    const eventsToForward = [\n      'init', 'gameState', 'roomCreated', 'roomJoined', 'roomRejoined',\n      'roomLeft', 'playerJoined', 'playerLeft', 'playerReady',\n      'gameStarted', 'gameOver', 'error', 'disconnect'\n    ];\n    \n    eventsToForward.forEach(eventName => {\n      socket.on(eventName, (data) => {\n        if (eventName === 'init' && typeof data === 'string') {\n          try {\n            const parsedData = JSON.parse(data);\n            this.log(`Converted string to object for init event`);\n            data = parsedData;\n          } catch (e) {\n            this.log(`Could not parse init string as JSON, creating default homescreen state`);\n            data = { \n              appPhase: 'homescreen',\n              socketId: socket.id,\n              players: {},\n              activePlayers: [],\n              readyPlayers: [],\n              gameInProgress: false\n            };\n          }\n        }\n        \n        this.emit(eventName, data);\n      });\n    });\n  }\n  \n  attemptRoomRejoin(socket) {\n    const session = getGameSession();\n    if (session && session.roomCode) {\n      this.log(`Attempting to rejoin room ${session.roomCode} as ${session.playerName}`);\n      \n      // Check if player was ready before disconnection\n      // This is determined by looking at the readyPlayers array in localStorage if available\n      let wasReady = false;\n      try {\n        // Try to determine if player was ready by checking local storage\n        const localReadyStatus = localStorage.getItem(`player_ready_${session.socketId}`);\n        if (localReadyStatus === 'true') {\n          wasReady = true;\n          this.log(`Player was previously ready, sending ready status in rejoin`);\n        }\n      } catch (e) {\n        this.log(`Could not determine previous ready status: ${e.message}`);\n      }\n      \n      socket.emit('rejoinRoom', {\n        roomCode: session.roomCode,\n        playerName: session.playerName,\n        previousSocketId: session.socketId || this.socketId,\n        wasReady: wasReady // Include ready status in rejoin request\n      });\n    }\n  }\n  \n  emit(eventName, data) {\n    // For non-EventEmitter events, send to server\n    if (eventName !== 'newListener' && eventName !== 'removeListener') {\n      if (this.activeSocket) {\n        this.activeSocket.emit(eventName, data);\n      } else {\n        this.log(`Cannot emit ${eventName}: no active socket`);\n      }\n    }\n    \n    // Always forward all events to local listeners\n    return super.emit(eventName, data);\n  }\n  \n  getSocket() {\n    return this.activeSocket;\n  }\n  \n  getSocketId() {\n    return this.socketId;\n  }\n  \n  disconnect() {\n    if (this.activeSocket) {\n      this.activeSocket.disconnect();\n    }\n    \n    this.activeSocket = null;\n    this.initialized = false;\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n}\n\n// Create a singleton instance\nconst serverManager = new ServerConnectionManager();\nexport default serverManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}